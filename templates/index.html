<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>US Border Redistricting Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geom:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Geom", sans-serif;
            font-optical-sizing: auto;
            font-weight: 400;
            font-style: normal;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        .header { text-align: center; padding: 20px; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; color: #fff; }
        .header p { font-size: 1.1em; color: #aaa; }
        .main { display: grid; grid-template-columns: 200px 1fr; gap: 20px; }
        .controls {
            background: linear-gradient(180deg, #252542 0%, #1a1a2e 100%);
            padding: 15px;
            border-radius: 12px;
            height: fit-content;
            border: 1px solid #333;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .control-group { margin-bottom: 12px; }
        .control-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 6px;
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        .control-group input[type="number"],
        .control-group select {
            width: 100%;
            padding: 10px 12px;
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            outline: none;
        }
        .control-group input[type="number"]:focus,
        .control-group select:focus {
            border-color: #00d4ff;
            box-shadow: 0 0 15px rgba(0,212,255,0.2);
        }
        .control-group input[type="number"]:hover,
        .control-group select:hover {
            border-color: #555;
        }
        .control-group select option {
            background: #1a1a2e;
            padding: 10px;
        }

        .buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
        }
        button {
            padding: 10px 10px;
            font-size: 11px;
            font-weight: 700;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        button:hover::before {
            left: 100%;
        }
        #startBtn {
            background: linear-gradient(135deg, #00d4ff 0%, #0088ff 100%);
            color: #000;
            box-shadow: 0 2px 10px rgba(0,212,255,0.3);
        }
        #startBtn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,212,255,0.4);
        }
        #stopBtn {
            background: linear-gradient(135deg, #ff4757 0%, #ff2d3a 100%);
            color: #fff;
            box-shadow: 0 2px 10px rgba(255,71,87,0.3);
        }
        #stopBtn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255,71,87,0.4);
        }
        #resetBtn {
            background: linear-gradient(135deg, #ffa500 0%, #ff8c00 100%);
            color: #000;
            box-shadow: 0 2px 10px rgba(255,165,0,0.3);
        }
        #resetBtn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255,165,0,0.4);
        }
        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        button:active:not(:disabled) {
            transform: translateY(0);
        }

        /* Iteration counter in sidebar */
        .iter-box {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #333;
            text-align: center;
        }
        .iter-box .iter-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 4px;
        }
        .iter-box .iter-value {
            font-size: 28px;
            color: #00d4ff;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0,212,255,0.4);
        }
        .viz {
            background: #252542;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #mapCanvas {
            border-radius: 8px;
            background: #ffffff00;
        }
        .loading { text-align: center; padding: 50px; }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Brainrot Dashboard */
        .viz-container { position: relative; width: fit-content; margin: 0 auto; }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
            width: 100%;
        }
        
        .dash-card {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
        }
        .dash-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent, #00d4ff), transparent);
            opacity: 0.5;
        }
        .dash-card.pulse::before {
            animation: pulse-glow 0.5s ease-out;
        }
        @keyframes pulse-glow {
            0% { opacity: 1; height: 4px; }
            100% { opacity: 0.5; height: 2px; }
        }
        
        .dash-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        .dash-value {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            transition: all 0.3s ease;
        }
        .dash-value.dem { color: #3b82f6; }
        .dash-value.rep { color: #ef4444; }
        .dash-value.neutral { color: #a855f7; }
        
        .dash-subtitle {
            font-size: 11px;
            color: #555;
            margin-top: 2px;
        }
        
        /* Sparkline */
        .sparkline {
            height: 30px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            margin-top: 8px;
        }
        .spark-bar {
            flex: 1;
            background: linear-gradient(to top, #00d4ff, #0088ff);
            border-radius: 2px 2px 0 0;
            min-height: 2px;
            transition: height 0.2s ease;
            opacity: 0.7;
        }
        .spark-bar:last-child { opacity: 1; }
        
        /* EV Bar Enhanced */
        .ev-section { grid-column: span 2; }
        .ev-bar-enhanced {
            display: flex;
            height: 40px;
            border-radius: 6px;
            overflow: hidden;
            background: #333;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .ev-dem-bar {
            background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
            height: 100%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 10px;
            font-weight: 700;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 2px 0 10px rgba(59,130,246,0.5);
        }
        .ev-rep-bar {
            background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
            height: 100%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-weight: 700;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: -2px 0 10px rgba(239,68,68,0.5);
        }
        .ev-center-line {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255,255,255,0.3);
            transform: translateX(-50%);
        }
        .ev-270-marker {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #666;
        }
        
        /* Histogram */
        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 40px;
            gap: 1px;
            margin-top: 5px;
        }
        .hist-bar {
            width: 8px;
            border-radius: 2px 2px 0 0;
            min-height: 2px;
            transition: height 0.3s ease, background 0.3s ease;
        }
        
        /* Mini stat row */
        .mini-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }
        .mini-stat {
            text-align: center;
        }
        .mini-stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #00d4ff;
        }
        .mini-stat-label {
            font-size: 9px;
            color: #555;
            text-transform: uppercase;
        }
        .winner-dem { color: #3b82f6 !important; }
        .winner-rep { color: #ef4444 !important; }
        .winner-tie { color: #a855f7 !important; }

        /* State tooltip */
        #stateTooltip {
            position: fixed;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px 14px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-width: 140px;
        }
        #stateTooltip .tooltip-name {
            font-weight: 600;
            font-size: 15px;
            color: #fff;
            margin-bottom: 6px;
        }
        #stateTooltip .tooltip-row {
            font-size: 13px;
            color: #aaa;
            margin: 3px 0;
        }
        #stateTooltip .tooltip-row span {
            color: #fff;
            font-weight: 500;
        }
        #stateTooltip .lean-dem { color: #3b82f6 !important; }
        #stateTooltip .lean-rep { color: #ef4444 !important; }
        #stateTooltip .lean-even { color: #a855f7 !important; }
    </style>
</head>
<body>
    <!-- State tooltip -->
    <div id="stateTooltip">
        <div class="tooltip-name" id="tooltipStateName"></div>
        <div class="tooltip-row">Counties: <span id="tooltipCountyCount"></span></div>
        <div class="tooltip-row">Population: <span id="tooltipPopulation"></span></div>
        <div class="tooltip-row">Electoral Votes: <span id="tooltipEV"></span></div>
        <div class="tooltip-row">Lean: <span id="tooltipLean"></span></div>
    </div>

    <div class="container">

        <div class="main">
            <div class="controls">
                <div class="iter-box">
                    <div class="iter-label">Iteration</div>
                    <div class="iter-value" id="iteration">0</div>
                </div>

                <div class="control-group">
                    <label>Total Iterations</label>
                    <input type="number" id="iterations" min="100" max="150000" value="5000" step="100">
                </div>

                <div class="control-group">
                    <label>Update Every</label>
                    <input type="number" id="renderEvery" min="1" max="500" value="25" step="1">
                </div>

                <div class="control-group">
                    <label>Color Mode</label>
                    <select id="colorModeSelect">
                        <option value="county-partisan">County Partisan</option>
                        <option value="state-partisan">State Partisan</option>
                        <option value="state">State Colors</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Target</label>
                    <select id="targetSelect">
                        <option value="Republican">GOP Victory</option>
                        <option value="Democratic">DEM Victory</option>
                        <option value="Tie">Electoral Tie</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Algorithm</label>
                    <select id="modeSelect">
                        <option value="standard">Standard</option>
                        <option value="follow_the_leader">Follow Leader</option>
                        <option value="bfs">BFS</option>
                        <option value="dfs">DFS</option>
                    </select>
                </div>

                <div class="buttons">
                    <button id="startBtn">Play</button>
                    <button id="stopBtn" disabled>Pause</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>

            <div class="viz">
                <div id="loadingState" class="loading">
                    <div class="spinner"></div>
                    <p>Loading map data...</p>
                </div>
                <div class="viz-container">
                    <canvas id="mapCanvas" style="display: none;"></canvas>
                </div>
                
                <div class="dashboard" id="dashboard" style="display: none;">
                    <!-- EV Bar - Full Width -->
                    <div class="dash-card ev-section" style="--accent: #a855f7;">
                        <div class="dash-label">Electoral College</div>
                        <div class="ev-270-marker">270 to win</div>
                        <div class="ev-bar-enhanced">
                            <div class="ev-dem-bar" id="evDemBar"><span id="evDem">0</span></div>
                            <div class="ev-rep-bar" id="evRepBar"><span id="evRep">0</span></div>
                            <div class="ev-center-line"></div>
                        </div>
                        <div class="mini-stats">
                            <div class="mini-stat">
                                <div class="mini-stat-value" id="winner" style="color: #a855f7;">-</div>
                                <div class="mini-stat-label">Projected</div>
                            </div>
                            <div class="mini-stat">
                                <div class="mini-stat-value" id="evMargin">0</div>
                                <div class="mini-stat-label">EV Margin</div>
                            </div>
                            <div class="mini-stat">
                                <div class="mini-stat-value" id="stateCount">48</div>
                                <div class="mini-stat-label">States</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Swing States -->
                    <div class="dash-card" id="swingCard" style="--accent: #fbbf24;">
                        <div class="dash-label">Swing States</div>
                        <div class="dash-value" id="swingStates">0</div>
                        <div class="dash-subtitle">within Â±5% lean</div>
                        <div class="sparkline" id="swingSparkline"></div>
                    </div>
                    
                    <!-- EV Margin -->
                    <div class="dash-card" id="fairnessCard" style="--accent: #a855f7;">
                        <div class="dash-label">Electoral Efficiency</div>
                        <div class="dash-value" id="fairnessScore">0%</div>
                        <div class="dash-subtitle">EV% minus PopVote%</div>
                        <div class="sparkline" id="fairnessSparkline"></div>
                    </div>
                    
                    <!-- Partisan Distribution Histogram -->
                    <div class="dash-card" style="--accent: #a855f7; grid-column: span 2;">
                        <div class="dash-label">State Partisan Distribution</div>
                        <div class="histogram" id="partisanHistogram"></div>
                        <div class="mini-stats" style="border: none; padding-top: 5px;">
                            <div class="mini-stat">
                                <div class="mini-stat-value dem" id="safeBlue">0</div>
                                <div class="mini-stat-label">Safe D</div>
                            </div>
                            <div class="mini-stat">
                                <div class="mini-stat-value" style="color: #60a5fa;" id="leanBlue">0</div>
                                <div class="mini-stat-label">Lean D</div>
                            </div>
                            <div class="mini-stat">
                                <div class="mini-stat-value" style="color: #a855f7;" id="tossup">0</div>
                                <div class="mini-stat-label">Tossup</div>
                            </div>
                            <div class="mini-stat">
                                <div class="mini-stat-value" style="color: #f87171;" id="leanRed">0</div>
                                <div class="mini-stat-label">Lean R</div>
                            </div>
                            <div class="mini-stat">
                                <div class="mini-stat-value rep" id="safeRed">0</div>
                                <div class="mini-stat-label">Safe R</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // Map data
        let geojson = null;
        let palette = [];
        let countyColors = {};
        let countyPaths = {};  // Pre-computed Path2D objects
        let countyEdges = {};  // geoid -> array of edges [{x1,y1,x2,y2}, ...]
        let neighbors = {};    // geoid -> [neighbor geoids]
        let sharedEdges = {};  // "geoid1-geoid2" -> Path2D of shared edge
        let partisanLean = {}; // geoid -> partisan lean value (-1 to 1)
        let population = {};   // geoid -> population
        let stateLeans = {};   // state -> avg partisan lean
        let countyToState = {}; // geoid -> state
        let colorMode = 'county-partisan'; // 'state', 'county-partisan', or 'state-partisan'
        let election = { winner: '-', r_ev: 0, d_ev: 0 };
        let bounds = null;
        let transform = null;

        // Tooltip data (computed once at init, updated on state changes)
        let stateNames = {};        // state abbrev -> full state name
        let stateCountyCounts = {}; // state abbrev -> number of counties
        let stateEVs = {};          // state abbrev -> electoral votes
        let statePopulations = {};  // state abbrev -> total population
        let hoveredState = null;    // Currently hovered state

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loadingState = document.getElementById('loadingState');
        // Dashboard elements
        const iterationEl = document.getElementById('iteration');
        const dashboard = document.getElementById('dashboard');
        const winnerEl = document.getElementById('winner');
        const evDemBar = document.getElementById('evDemBar');
        const evRepBar = document.getElementById('evRepBar');
        const evDemEl = document.getElementById('evDem');
        const evRepEl = document.getElementById('evRep');
        const evMarginEl = document.getElementById('evMargin');
        const stateCountEl = document.getElementById('stateCount');
        const swingStatesEl = document.getElementById('swingStates');
        const swingCard = document.getElementById('swingCard');
        const fairnessScoreEl = document.getElementById('fairnessScore');
        const fairnessCard = document.getElementById('fairnessCard');
        const partisanHistogram = document.getElementById('partisanHistogram');
        const swingSparkline = document.getElementById('swingSparkline');
        const fairnessSparkline = document.getElementById('fairnessSparkline');
        const safeBlueEl = document.getElementById('safeBlue');
        const leanBlueEl = document.getElementById('leanBlue');
        const tossupEl = document.getElementById('tossup');
        const leanRedEl = document.getElementById('leanRed');
        const safeRedEl = document.getElementById('safeRed');
        
        // History for sparklines (last 20 values)
        const SPARKLINE_LENGTH = 20;
        let swingHistory = [];
        let fairnessHistory = [];

        // Calculate dashboard metrics
        function calculateDashboardMetrics() {
            const states = Object.keys(stateLeans);
            let swingCount = 0;
            let safeD = 0, leanD = 0, tossup = 0, leanR = 0, safeR = 0;

            for (const state of states) {
                const lean = stateLeans[state] || 0;
                const absLean = Math.abs(lean);

                if (absLean <= 0.05) {
                    swingCount++;
                    tossup++;
                } else if (lean < -0.15) {
                    safeD++;
                } else if (lean < -0.05) {
                    leanD++;
                } else if (lean > 0.15) {
                    safeR++;
                } else if (lean > 0.05) {
                    leanR++;
                }
            }

            // EV Margin: (winner EV %) - (winner popular vote %)
            // Popular vote is fixed based on county partisan lean * population
            let demPopVote = 0, repPopVote = 0;
            for (const [geoid, lean] of Object.entries(partisanLean)) {
                const pop = population[geoid] || 0;
                // lean > 0 means R, lean < 0 means D
                // Approximate: if lean is 0.1, then 55% voted R, 45% voted D
                const rPct = (1 + lean) / 2;
                const dPct = 1 - rPct;
                repPopVote += pop * rPct;
                demPopVote += pop * dPct;
            }
            const totalPopVote = demPopVote + repPopVote;
            const demPopPct = totalPopVote > 0 ? (demPopVote / totalPopVote) * 100 : 50;
            const repPopPct = totalPopVote > 0 ? (repPopVote / totalPopVote) * 100 : 50;

            // EV percentages from election object
            const totalEV = election.d_ev + election.r_ev;
            const demEVPct = totalEV > 0 ? (election.d_ev / totalEV) * 100 : 50;
            const repEVPct = totalEV > 0 ? (election.r_ev / totalEV) * 100 : 50;

            // EV margin = winner's EV% - winner's pop%
            // Positive means EV overperformance, negative means underperformance
            const evWinner = election.d_ev > election.r_ev ? 'dem' : election.r_ev > election.d_ev ? 'rep' : 'tie';
            let evMarginValue = 0;
            if (evWinner === 'dem') {
                evMarginValue = demEVPct - demPopPct;
            } else if (evWinner === 'rep') {
                evMarginValue = repEVPct - repPopPct;
            }

            return { swingCount, evMarginValue, evWinner, categories: { safeD, leanD, tossup, leanR, safeR }, stateCount: states.length };
        }

        // Update sparkline
        function updateSparkline(container, history, maxVal) {
            if (!container) return;
            const max = maxVal || Math.max(...history, 1);
            container.innerHTML = history.map(v =>
                `<div class="spark-bar" style="height: ${Math.max(2, (v / max) * 30)}px"></div>`
            ).join('');
        }

        // Update sparkline with party color
        function updateSparklineColored(container, history, maxVal, winner) {
            if (!container) return;
            const max = maxVal || Math.max(...history.map(Math.abs), 1);
            const color = winner === 'dem' ? 'linear-gradient(to top, #2563eb, #3b82f6)' :
                          winner === 'rep' ? 'linear-gradient(to top, #dc2626, #ef4444)' :
                          'linear-gradient(to top, #7c3aed, #a855f7)';
            container.innerHTML = history.map(v =>
                `<div class="spark-bar" style="height: ${Math.max(2, (Math.abs(v) / max) * 30)}px; background: ${color};"></div>`
            ).join('');
        }

        // Update partisan histogram
        function updateHistogram() {
            if (!partisanHistogram) return;
            const bins = new Array(21).fill(0);

            for (const state of Object.keys(stateLeans)) {
                const lean = stateLeans[state] || 0;
                const binIdx = Math.min(20, Math.max(0, Math.floor((lean + 1) * 10)));
                bins[binIdx]++;
            }

            const maxBin = Math.max(...bins, 1);

            partisanHistogram.innerHTML = bins.map((count, i) => {
                const lean = (i - 10) / 10;
                let color;
                if (lean < -0.15) color = '#2563eb';
                else if (lean < -0.05) color = '#60a5fa';
                else if (lean < 0.05) color = '#a855f7';
                else if (lean < 0.15) color = '#f87171';
                else color = '#dc2626';

                const height = Math.max(2, (count / maxBin) * 40);
                return `<div class="hist-bar" style="height: ${height}px; background: ${color};"></div>`;
            }).join('');
        }

        // Update entire dashboard
        function updateDashboard() {
            const metrics = calculateDashboardMetrics();

            // Update swing states
            if (swingStatesEl) swingStatesEl.textContent = metrics.swingCount;
            swingHistory.push(metrics.swingCount);
            if (swingHistory.length > SPARKLINE_LENGTH) swingHistory.shift();
            updateSparklineColored(swingSparkline, swingHistory, 20, metrics.evWinner);

            // Pulse effect
            if (swingCard && swingHistory.length > 1 && swingHistory[swingHistory.length - 1] !== swingHistory[swingHistory.length - 2]) {
                swingCard.classList.add('pulse');
                setTimeout(() => swingCard.classList.remove('pulse'), 500);
            }

            // Update EV margin (EV% - PopVote%)
            if (fairnessScoreEl) {
                const sign = metrics.evMarginValue >= 0 ? '+' : '';
                fairnessScoreEl.textContent = sign + metrics.evMarginValue.toFixed(1) + '%';
                fairnessScoreEl.style.color = metrics.evWinner === 'dem' ? '#3b82f6' : 
                                               metrics.evWinner === 'rep' ? '#ef4444' : '#a855f7';
            }
            fairnessHistory.push(metrics.evMarginValue);
            if (fairnessHistory.length > SPARKLINE_LENGTH) fairnessHistory.shift();
            // Color sparkline by winner
            updateSparklineColored(fairnessSparkline, fairnessHistory, 30, metrics.evWinner);

            // Update histogram
            updateHistogram();

            // Update category counts
            if (safeBlueEl) safeBlueEl.textContent = metrics.categories.safeD;
            if (leanBlueEl) leanBlueEl.textContent = metrics.categories.leanD;
            if (tossupEl) tossupEl.textContent = metrics.categories.tossup;
            if (leanRedEl) leanRedEl.textContent = metrics.categories.leanR;
            if (safeRedEl) safeRedEl.textContent = metrics.categories.safeR;

            // Update state count
            if (stateCountEl) stateCountEl.textContent = metrics.stateCount;
        }

        const iterationsInput = document.getElementById('iterations');
        const renderEveryInput = document.getElementById('renderEvery');
        const targetSelect = document.getElementById('targetSelect');
        const modeSelect = document.getElementById('modeSelect');
        let currentScore = 0;

        // Tooltip elements
        const stateTooltip = document.getElementById('stateTooltip');
        const tooltipStateName = document.getElementById('tooltipStateName');
        const tooltipCountyCount = document.getElementById('tooltipCountyCount');
        const tooltipPopulation = document.getElementById('tooltipPopulation');
        const tooltipEV = document.getElementById('tooltipEV');
        const tooltipLean = document.getElementById('tooltipLean');

        iterationsInput.oninput = () => {
            document.getElementById('iterationsValue').textContent = iterationsInput.value;
        };
        renderEveryInput.oninput = () => {
            document.getElementById('renderEveryValue').textContent = renderEveryInput.value;
        };

        // Color mode select
        const colorModeSelect = document.getElementById('colorModeSelect');
        colorModeSelect.onchange = () => {
            colorMode = colorModeSelect.value;
            render();
        };

        // Update election display
        function updateElectionDisplay() {
            const totalEV = election.r_ev + election.d_ev;
            const demPct = totalEV > 0 ? (election.d_ev / totalEV) * 100 : 50;
            const repPct = totalEV > 0 ? (election.r_ev / totalEV) * 100 : 50;

            if (evDemBar) evDemBar.style.width = demPct + '%';
            if (evRepBar) evRepBar.style.width = repPct + '%';
            if (evDemEl) evDemEl.textContent = election.d_ev;
            if (evRepEl) evRepEl.textContent = election.r_ev;

            // Update EV margin
            const margin = Math.abs(election.d_ev - election.r_ev);
            if (evMarginEl) evMarginEl.textContent = margin;

            // Update winner display
            if (winnerEl) {
                winnerEl.textContent = election.winner === 'Democratic' ? 'DEM' : 
                                       election.winner === 'Republican' ? 'GOP' : 'TIE';
                winnerEl.style.color = election.winner === 'Democratic' ? '#3b82f6' : 
                                       election.winner === 'Republican' ? '#ef4444' : '#a855f7';
            }
        }

        // Convert partisan lean (-1 to 1) to color (blue to red)
        function leanToColor(lean) {
            // Clamp lean to -1 to 1 range
            lean = Math.max(-1, Math.min(1, lean));

            // Use a more perceptually uniform scale
            // At 0: purple/gray, negative: blue, positive: red
            if (lean < 0) {
                // Democrat (blue) - lean is negative
                // -1 = pure blue, 0 = light purple
                const t = Math.abs(lean); // 0 to 1
                const r = Math.round(200 - t * 180);  // 200 -> 20
                const g = Math.round(200 - t * 180);  // 200 -> 20
                const b = Math.round(220 + t * 35);   // 220 -> 255
                return `rgb(${r},${g},${b})`;
            } else {
                // Republican (red) - lean is positive
                // +1 = pure red, 0 = light purple
                const t = lean; // 0 to 1
                const r = Math.round(220 + t * 35);   // 220 -> 255
                const g = Math.round(200 - t * 180);  // 200 -> 20
                const b = Math.round(200 - t * 180);  // 200 -> 20
                return `rgb(${r},${g},${b})`;
            }
        }

        // Format partisan lean for display
        function formatLean(lean) {
            if (lean === undefined || lean === null) return 'N/A';
            const pct = Math.abs(lean * 100).toFixed(2);
            if (Math.abs(lean) < 0.000005) return 'EVEN';
            return lean > 0 ? 'R+' + pct : 'D+' + pct;
        }

        // Get CSS class for lean
        function getLeanClass(lean) {
            if (lean === undefined || lean === null || Math.abs(lean) < 0.000005) return 'lean-even';
            return lean > 0 ? 'lean-rep' : 'lean-dem';
        }

        // Build state names and county counts from geojson
        function buildStateData() {
            stateNames = {};
            stateCountyCounts = {};

            // Extract from geojson properties
            for (const feature of geojson.features) {
                const props = feature.properties;
                const stateAbbrev = props.STUSPS;
                const stateName = props.STATE_NAME;

                if (stateAbbrev && stateName) {
                    stateNames[stateAbbrev] = stateName;
                }
            }

            // Count counties per state from countyToState
            updateStateCountyCounts();
        }

        // Update county counts and populations when state assignments change
        function updateStateCountyCounts() {
            stateCountyCounts = {};
            statePopulations = {};
            for (const [geoid, state] of Object.entries(countyToState)) {
                stateCountyCounts[state] = (stateCountyCounts[state] || 0) + 1;
                statePopulations[state] = (statePopulations[state] || 0) + (population[geoid] || 0);
            }
            // Recompute EVs based on new populations
            updateStateEVs();
        }

        // Recompute electoral votes based on state populations
        function updateStateEVs() {
            const totalPop = Object.values(statePopulations).reduce((a, b) => a + b, 0);
            if (totalPop === 0) return;
            stateEVs = {};
            for (const [state, pop] of Object.entries(statePopulations)) {
                stateEVs[state] = Math.round(pop * 538 / totalPop);
            }
        }

        // Find which county (and thus state) is under the mouse
        function findStateAtPoint(x, y) {
            for (const [geoid, path] of Object.entries(countyPaths)) {
                if (ctx.isPointInPath(path, x, y)) {
                    return countyToState[geoid];
                }
            }
            return null;
        }

        // Update tooltip content without repositioning (for live updates during animation)
        function updateTooltipContent(state) {
            if (!state) return;

            const stateName = stateNames[state] || state;
            const countyCount = stateCountyCounts[state] || 0;
            const pop = statePopulations[state] || 0;
            const ev = stateEVs[state] || 0;
            const lean = stateLeans[state];

            tooltipStateName.textContent = stateName;
            tooltipCountyCount.textContent = countyCount;
            tooltipPopulation.textContent = pop.toLocaleString();
            tooltipEV.textContent = ev;
            tooltipLean.textContent = formatLean(lean);
            tooltipLean.className = getLeanClass(lean);
        }

        // Show tooltip for a state
        function showTooltip(state, mouseX, mouseY) {
            if (!state) {
                stateTooltip.style.display = 'none';
                return;
            }

            updateTooltipContent(state);

            // Position tooltip near mouse, offset to avoid cursor
            const offsetX = 15;
            const offsetY = 15;
            let left = mouseX + offsetX;
            let top = mouseY + offsetY;

            // Show briefly to measure
            stateTooltip.style.display = 'block';
            const tooltipWidth = stateTooltip.offsetWidth;
            const tooltipHeight = stateTooltip.offsetHeight;

            // Keep tooltip on screen
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (left + tooltipWidth > viewportWidth - 10) {
                left = mouseX - tooltipWidth - offsetX;
            }
            if (top + tooltipHeight > viewportHeight - 10) {
                top = mouseY - tooltipHeight - offsetY;
            }

            stateTooltip.style.left = left + 'px';
            stateTooltip.style.top = top + 'px';
        }

        // Canvas mouse event handlers
        function setupTooltipHandlers() {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const state = findStateAtPoint(x, y);
                hoveredState = state;
                showTooltip(state, e.clientX, e.clientY);
            });

            canvas.addEventListener('mouseleave', () => {
                hoveredState = null;
                stateTooltip.style.display = 'none';
            });
        }

        // Compute bounding box of GeoJSON
        function computeBounds(geojson) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const feature of geojson.features) {
                const coords = feature.geometry.coordinates;
                processCoords(coords, (x, y) => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            }
            return { minX, minY, maxX, maxY };
        }

        function processCoords(coords, fn) {
            if (typeof coords[0] === 'number') {
                fn(coords[0], coords[1]);
            } else {
                for (const c of coords) processCoords(c, fn);
            }
        }

        // Build Path2D for a geometry
        function buildPath(geometry) {
            const path = new Path2D();
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                drawPolygon(path, coords);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    drawPolygon(path, poly);
                }
            }
            return path;
        }

        function drawPolygon(path, rings) {
            for (const ring of rings) {
                let first = true;
                for (const [x, y] of ring) {
                    const [px, py] = project(x, y);
                    if (first) {
                        path.moveTo(px, py);
                        first = false;
                    } else {
                        path.lineTo(px, py);
                    }
                }
                path.closePath();
            }
        }

        function project(lon, lat) {
            const x = (lon - bounds.minX) * transform.scale + transform.offsetX;
            const y = (bounds.maxY - lat) * transform.scale + transform.offsetY;
            return [x, y];
        }

        // Pre-compute all county paths and edges
        function precomputePaths() {
            countyPaths = {};
            countyEdges = {};

            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                countyPaths[geoid] = buildPath(feature.geometry);
                countyEdges[geoid] = extractEdges(feature.geometry);
            }

            // Pre-compute shared edges between neighbors
            precomputeSharedEdges();
        }

        // Extract all edges from a geometry as line segments
        function extractEdges(geometry) {
            const edges = [];
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                extractPolygonEdges(coords, edges);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    extractPolygonEdges(poly, edges);
                }
            }
            return edges;
        }

        function extractPolygonEdges(rings, edges) {
            for (const ring of rings) {
                for (let i = 0; i < ring.length - 1; i++) {
                    const [x1, y1] = project(ring[i][0], ring[i][1]);
                    const [x2, y2] = project(ring[i + 1][0], ring[i + 1][1]);
                    // Store edge with normalized key for comparison
                    edges.push({ x1, y1, x2, y2 });
                }
            }
        }

        // Create a normalized key for an edge (so A->B and B->A match)
        function edgeKey(x1, y1, x2, y2) {
            // Round to avoid floating point issues
            const r = (v) => Math.round(v * 100) / 100;
            const p1 = `${r(x1)},${r(y1)}`;
            const p2 = `${r(x2)},${r(y2)}`;
            return p1 < p2 ? `${p1}-${p2}` : `${p2}-${p1}`;
        }

        // Pre-compute shared edges between neighboring counties
        function precomputeSharedEdges() {
            sharedEdges = {};
            const processed = new Set();

            for (const geoid of Object.keys(countyEdges)) {
                const myNeighbors = neighbors[geoid] || [];
                const myEdgeSet = new Set(countyEdges[geoid].map(e => edgeKey(e.x1, e.y1, e.x2, e.y2)));

                for (const neighborId of myNeighbors) {
                    const pairKey = geoid < neighborId ? `${geoid}-${neighborId}` : `${neighborId}-${geoid}`;
                    if (processed.has(pairKey)) continue;
                    processed.add(pairKey);

                    if (!countyEdges[neighborId]) continue;

                    // Find shared edges
                    const path = new Path2D();
                    let hasShared = false;

                    for (const edge of countyEdges[neighborId]) {
                        const key = edgeKey(edge.x1, edge.y1, edge.x2, edge.y2);
                        if (myEdgeSet.has(key)) {
                            path.moveTo(edge.x1, edge.y1);
                            path.lineTo(edge.x2, edge.y2);
                            hasShared = true;
                        }
                    }

                    if (hasShared) {
                        sharedEdges[pairKey] = path;
                    }
                }
            }
            console.log(`Pre-computed ${Object.keys(sharedEdges).length} shared edges`);
        }

        // Render the map
        function render() {
            const t0 = performance.now();

            ctx.fillStyle = '#252542';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pass 1: Fill all counties
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                const path = countyPaths[geoid];
                let color;

                if (colorMode === 'county-partisan') {
                    // Each county colored by its own partisan lean
                    const lean = partisanLean[geoid];
                    color = lean !== undefined ? leanToColor(lean) : '#cccccc';
                } else if (colorMode === 'state-partisan') {
                    // Each county colored by its state's average partisan lean
                    const state = countyToState[geoid];
                    const lean = state ? stateLeans[state] : undefined;
                    color = lean !== undefined ? leanToColor(lean) : '#cccccc';
                } else {
                    // Unique state colors
                    const colorIdx = countyColors[geoid];
                    color = palette[colorIdx] || '#cccccc';
                }

                ctx.fillStyle = color;
                ctx.fill(path);
            }

            // Pass 2: Draw thin county borders
            ctx.strokeStyle = '#00000022';
            ctx.lineWidth = 0.25;
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                ctx.stroke(countyPaths[geoid]);
            }

            // Pass 3: Draw thick state borders using pre-computed shared edges
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            for (const [pairKey, path] of Object.entries(sharedEdges)) {
                const [geoid1, geoid2] = pairKey.split('-');
                const color1 = countyColors[geoid1];
                const color2 = countyColors[geoid2];

                // Only draw if counties belong to different states
                if (color1 !== color2) {
                    ctx.stroke(path);
                }
            }

        }

        // Initialize
        async function init() {
            try {
                // Load GeoJSON and initial colors in parallel
                const [geoRes, initRes] = await Promise.all([
                    fetch('/api/geojson'),
                    fetch('/api/init')
                ]);

                geojson = await geoRes.json();
                const initData = await initRes.json();
                palette = initData.palette;
                countyColors = initData.colors;
                neighbors = initData.neighbors;
                partisanLean = initData.partisanLean || {};
                population = initData.population || {};
                stateLeans = initData.stateLeans || {};
                countyToState = initData.countyToState || {};
                stateEVs = initData.stateEVs || {};
                statePopulations = initData.statePopulations || {};
                election = initData.election || { winner: '-', r_ev: 0, d_ev: 0 };

                console.log(`Loaded ${geojson.features.length} counties, ${palette.length} colors, ${Object.keys(neighbors).length} neighbor entries, ${Object.keys(partisanLean).length} partisan lean values, ${Object.keys(stateLeans).length} state leans`);

                // Setup canvas
                const width = 1100;
                const height = 500;
                canvas.width = width;
                canvas.height = height;

                // Compute transform
                bounds = computeBounds(geojson);
                const geoWidth = bounds.maxX - bounds.minX;
                const geoHeight = bounds.maxY - bounds.minY;
                const scaleX = (width - 40) / geoWidth;
                const scaleY = (height - 40) / geoHeight;
                transform = {
                    scale: Math.min(scaleX, scaleY),
                    offsetX: 20,
                    offsetY: 20
                };

                // Pre-compute paths
                precomputePaths();

                // Build state data for tooltips
                buildStateData();

                // Setup tooltip event handlers
                setupTooltipHandlers();

                // Initial render
                render();

                // Show canvas
                loadingState.style.display = 'none';
                canvas.style.display = 'block';
                if (dashboard) dashboard.style.display = 'grid';
                updateElectionDisplay();
                updateDashboard();

            } catch (err) {
                console.error('Init error:', err);
                loadingState.innerHTML = '<p>Error loading map: ' + err.message + '</p>';
            }
        }

        // Socket handlers
        socket.on('color_update', (data) => {
            countyColors = data.colors;
            if (data.stateLeans) stateLeans = data.stateLeans;
            if (data.countyToState) {
                countyToState = data.countyToState;
                updateStateCountyCounts();
            }
            if (data.election) {
                election = data.election;
                updateElectionDisplay();
            }
            if (data.score !== undefined) {
                currentScore = data.score;
            }
            render();

            // Update brainrot dashboard
            updateDashboard();

            // Refresh tooltip if currently hovering over a state
            if (hoveredState && stateTooltip.style.display !== 'none') {
                updateTooltipContent(hoveredState);
            }

            if (iterationEl) iterationEl.textContent = data.generation.toLocaleString();
        });

        socket.on('algorithm_started', (data) => {
        });

        socket.on('algorithm_complete', () => {
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        socket.on('error', (data) => {
            console.error('Error:', data.message);
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        // Button handlers
        startBtn.onclick = () => {
            socket.emit('start_algorithm', {
                generations: parseInt(iterationsInput.value),
                render_every: parseInt(renderEveryInput.value),
                target: targetSelect.value,
                mode: modeSelect.value
            });
            startBtn.disabled = true;
            stopBtn.disabled = false;
        };

        stopBtn.onclick = () => {
            socket.emit('stop_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
        };

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.onclick = () => {
            socket.emit('reset_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
        };

        socket.on('reset_complete', (data) => {
            countyColors = data.colors;
            if (data.countyToState) {
                countyToState = data.countyToState;
                updateStateCountyCounts();
            }
            if (data.stateLeans) stateLeans = data.stateLeans;
            render();
            iterationEl.textContent = '0';
        });

        // Start
        init();
    </script>
</body>
</html>
