<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>US Border Redistricting Simulation</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        .header { text-align: center; padding: 20px; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; color: #fff; }
        .header p { font-size: 1.1em; color: #aaa; }
        .main { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        .controls {
            background: #252542;
            padding: 25px;
            border-radius: 10px;
            height: fit-content;
        }
        .control-group { margin-bottom: 25px; }
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #fff;
        }
        .control-group input[type="range"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 5px;
            color: #fff;
        }
        .range-value { text-align: right; color: #aaa; font-size: 14px; margin-top: 5px; }
        .buttons { display: flex; gap: 10px; margin-bottom: 20px; }
        button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        #startBtn { background: #00d4ff; color: #000; }
        #startBtn:hover:not(:disabled) { background: #00bfea; transform: translateY(-2px); }
        #stopBtn { background: #ff4757; color: #fff; }
        #stopBtn:hover:not(:disabled) { background: #ee2e3f; transform: translateY(-2px); }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        .status-box {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .status-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        .status-value { font-size: 16px; color: #fff; }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #1a1a2e;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #0088ff);
            width: 0%;
            transition: width 0.1s;
        }
        .viz {
            background: #252542;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #mapCanvas {
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            background: #fff;
        }
        .loading { text-align: center; padding: 50px; }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
        }
        .stat {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 5px;
            text-align: center;
        }
        .stat-label { font-size: 11px; color: #aaa; text-transform: uppercase; margin-bottom: 3px; }
        .stat-value { font-size: 22px; font-weight: 700; color: #00d4ff; }
        .info {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #00d4ff;
            margin-bottom: 20px;
        }
        .info p { margin: 5px 0; color: #aaa; font-size: 14px; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>US Border Redistricting</h1>
            <p>Watch state borders evolve in real-time</p>
        </div>

        <div class="main">
            <div class="controls">
                <div class="info">
                    <p><strong>How it works:</strong></p>
                    <p>Each iteration, one state absorbs an adjacent county. Colors indicate state groupings.</p>
                </div>

                <div class="control-group">
                    <label>Iterations</label>
                    <input type="range" id="iterations" min="100" max="150000" value="5000" step="100">
                    <div class="range-value"><span id="iterationsValue">5000</span></div>
                </div>

                <div class="control-group">
                    <label>Update Every N Iterations</label>
                    <input type="range" id="renderEvery" min="1" max="500" value="25" step="1">
                    <div class="range-value"><span id="renderEveryValue">25</span></div>
                </div>

                <div class="buttons">
                    <button id="startBtn">Play</button>
                    <button id="stopBtn" disabled>Stop</button>
                </div>

                <div class="status-box">
                    <div class="status-label">Status</div>
                    <div class="status-value" id="statusText">Loading...</div>
                </div>

                <div class="status-box">
                    <div class="status-label">Progress</div>
                    <div class="status-value" id="progressText">0 / 0</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                </div>
            </div>

            <div class="viz">
                <div id="loadingState" class="loading">
                    <div class="spinner"></div>
                    <p>Loading map data...</p>
                </div>
                <canvas id="mapCanvas" style="display: none;"></canvas>
                <div class="stats" id="stats" style="display: none;">
                    <div class="stat">
                        <div class="stat-label">Iteration</div>
                        <div class="stat-value" id="iteration">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Progress</div>
                        <div class="stat-value" id="percent">0%</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Render Time</div>
                        <div class="stat-value" id="renderTime">0ms</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // Map data
        let geojson = null;
        let palette = [];
        let countyColors = {};
        let countyPaths = {};  // Pre-computed Path2D objects
        let countyEdges = {};  // geoid -> array of edges [{x1,y1,x2,y2}, ...]
        let neighbors = {};    // geoid -> [neighbor geoids]
        let sharedEdges = {};  // "geoid1-geoid2" -> Path2D of shared edge
        let bounds = null;
        let transform = null;

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loadingState = document.getElementById('loadingState');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const stats = document.getElementById('stats');
        const iterationEl = document.getElementById('iteration');
        const percentEl = document.getElementById('percent');
        const renderTimeEl = document.getElementById('renderTime');
        const iterationsInput = document.getElementById('iterations');
        const renderEveryInput = document.getElementById('renderEvery');

        iterationsInput.oninput = () => {
            document.getElementById('iterationsValue').textContent = iterationsInput.value;
        };
        renderEveryInput.oninput = () => {
            document.getElementById('renderEveryValue').textContent = renderEveryInput.value;
        };

        // Compute bounding box of GeoJSON
        function computeBounds(geojson) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const feature of geojson.features) {
                const coords = feature.geometry.coordinates;
                processCoords(coords, (x, y) => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            }
            return { minX, minY, maxX, maxY };
        }

        function processCoords(coords, fn) {
            if (typeof coords[0] === 'number') {
                fn(coords[0], coords[1]);
            } else {
                for (const c of coords) processCoords(c, fn);
            }
        }

        // Build Path2D for a geometry
        function buildPath(geometry) {
            const path = new Path2D();
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                drawPolygon(path, coords);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    drawPolygon(path, poly);
                }
            }
            return path;
        }

        function drawPolygon(path, rings) {
            for (const ring of rings) {
                let first = true;
                for (const [x, y] of ring) {
                    const [px, py] = project(x, y);
                    if (first) {
                        path.moveTo(px, py);
                        first = false;
                    } else {
                        path.lineTo(px, py);
                    }
                }
                path.closePath();
            }
        }

        function project(lon, lat) {
            const x = (lon - bounds.minX) * transform.scale + transform.offsetX;
            const y = (bounds.maxY - lat) * transform.scale + transform.offsetY;
            return [x, y];
        }

        // Pre-compute all county paths and edges
        function precomputePaths() {
            countyPaths = {};
            countyEdges = {};

            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                countyPaths[geoid] = buildPath(feature.geometry);
                countyEdges[geoid] = extractEdges(feature.geometry);
            }

            // Pre-compute shared edges between neighbors
            precomputeSharedEdges();
        }

        // Extract all edges from a geometry as line segments
        function extractEdges(geometry) {
            const edges = [];
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                extractPolygonEdges(coords, edges);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    extractPolygonEdges(poly, edges);
                }
            }
            return edges;
        }

        function extractPolygonEdges(rings, edges) {
            for (const ring of rings) {
                for (let i = 0; i < ring.length - 1; i++) {
                    const [x1, y1] = project(ring[i][0], ring[i][1]);
                    const [x2, y2] = project(ring[i + 1][0], ring[i + 1][1]);
                    // Store edge with normalized key for comparison
                    edges.push({ x1, y1, x2, y2 });
                }
            }
        }

        // Create a normalized key for an edge (so A->B and B->A match)
        function edgeKey(x1, y1, x2, y2) {
            // Round to avoid floating point issues
            const r = (v) => Math.round(v * 100) / 100;
            const p1 = `${r(x1)},${r(y1)}`;
            const p2 = `${r(x2)},${r(y2)}`;
            return p1 < p2 ? `${p1}-${p2}` : `${p2}-${p1}`;
        }

        // Pre-compute shared edges between neighboring counties
        function precomputeSharedEdges() {
            sharedEdges = {};
            const processed = new Set();

            for (const geoid of Object.keys(countyEdges)) {
                const myNeighbors = neighbors[geoid] || [];
                const myEdgeSet = new Set(countyEdges[geoid].map(e => edgeKey(e.x1, e.y1, e.x2, e.y2)));

                for (const neighborId of myNeighbors) {
                    const pairKey = geoid < neighborId ? `${geoid}-${neighborId}` : `${neighborId}-${geoid}`;
                    if (processed.has(pairKey)) continue;
                    processed.add(pairKey);

                    if (!countyEdges[neighborId]) continue;

                    // Find shared edges
                    const path = new Path2D();
                    let hasShared = false;

                    for (const edge of countyEdges[neighborId]) {
                        const key = edgeKey(edge.x1, edge.y1, edge.x2, edge.y2);
                        if (myEdgeSet.has(key)) {
                            path.moveTo(edge.x1, edge.y1);
                            path.lineTo(edge.x2, edge.y2);
                            hasShared = true;
                        }
                    }

                    if (hasShared) {
                        sharedEdges[pairKey] = path;
                    }
                }
            }
            console.log(`Pre-computed ${Object.keys(sharedEdges).length} shared edges`);
        }

        // Render the map
        function render() {
            const t0 = performance.now();

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pass 1: Fill all counties
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                const colorIdx = countyColors[geoid];
                const color = palette[colorIdx] || '#cccccc';
                const path = countyPaths[geoid];

                ctx.fillStyle = color;
                ctx.fill(path);
            }

            // Pass 2: Draw thin county borders
            ctx.strokeStyle = '#00000022';
            ctx.lineWidth = 0.25;
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                ctx.stroke(countyPaths[geoid]);
            }

            // Pass 3: Draw thick state borders using pre-computed shared edges
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            for (const [pairKey, path] of Object.entries(sharedEdges)) {
                const [geoid1, geoid2] = pairKey.split('-');
                const color1 = countyColors[geoid1];
                const color2 = countyColors[geoid2];

                // Only draw if counties belong to different states
                if (color1 !== color2) {
                    ctx.stroke(path);
                }
            }

            const elapsed = performance.now() - t0;
            renderTimeEl.textContent = elapsed.toFixed(1) + 'ms';
        }

        // Initialize
        async function init() {
            try {
                // Load GeoJSON and initial colors in parallel
                const [geoRes, initRes] = await Promise.all([
                    fetch('/api/geojson'),
                    fetch('/api/init')
                ]);

                geojson = await geoRes.json();
                const initData = await initRes.json();
                palette = initData.palette;
                countyColors = initData.colors;
                neighbors = initData.neighbors;

                console.log(`Loaded ${geojson.features.length} counties, ${palette.length} colors, ${Object.keys(neighbors).length} neighbor entries`);

                // Setup canvas
                const width = 1200;
                const height = 750;
                canvas.width = width;
                canvas.height = height;

                // Compute transform
                bounds = computeBounds(geojson);
                const geoWidth = bounds.maxX - bounds.minX;
                const geoHeight = bounds.maxY - bounds.minY;
                const scaleX = (width - 40) / geoWidth;
                const scaleY = (height - 40) / geoHeight;
                transform = {
                    scale: Math.min(scaleX, scaleY),
                    offsetX: 20,
                    offsetY: 20
                };

                // Pre-compute paths
                precomputePaths();

                // Initial render
                render();

                // Show canvas
                loadingState.style.display = 'none';
                canvas.style.display = 'block';
                stats.style.display = 'grid';
                statusText.textContent = 'Ready';

            } catch (err) {
                console.error('Init error:', err);
                loadingState.innerHTML = '<p>Error loading map: ' + err.message + '</p>';
            }
        }

        // Socket handlers
        socket.on('color_update', (data) => {
            countyColors = data.colors;
            render();

            const prog = (data.generation / data.total) * 100;
            progressBar.style.width = prog + '%';
            progressText.textContent = `${data.generation} / ${data.total}`;
            iterationEl.textContent = data.generation;
            percentEl.textContent = Math.round(prog) + '%';
        });

        socket.on('algorithm_started', (data) => {
            progressText.textContent = `0 / ${data.iterations}`;
        });

        socket.on('algorithm_complete', () => {
            statusText.textContent = 'Complete';
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        socket.on('error', (data) => {
            statusText.textContent = 'Error: ' + data.message;
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        // Button handlers
        startBtn.onclick = () => {
            socket.emit('start_algorithm', {
                generations: parseInt(iterationsInput.value),
                render_every: parseInt(renderEveryInput.value)
            });
            startBtn.disabled = true;
            stopBtn.disabled = false;
            statusText.textContent = 'Running';
            stats.style.display = 'grid';
        };

        stopBtn.onclick = () => {
            socket.emit('stop_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusText.textContent = 'Stopped';
        };

        // Start
        init();
    </script>
</body>
</html>
