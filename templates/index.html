<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>US Border Redistricting Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geom:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Geom", sans-serif;
            font-optical-sizing: auto;
            font-weight: 400;
            font-style: normal;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1800px; margin: 0 auto; }

        .viz {
            background: #252542;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Floating controls panel */
        .floating-controls {
            position: absolute;
            top: 10px;
            left: -320px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: "Geom", sans-serif;
        }

        /* Glowy iteration counter */
        .iter-box {
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            text-align: center;
            box-shadow:
                0 0 20px rgba(0, 212, 255, 0.15),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .iter-box .iter-label {
            font-size: 8px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 2px;
            text-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
        }
        .iter-box .iter-value {
            font-size: 24px;
            color: #00d4ff;
            font-weight: 700;
            line-height: 1;
            text-shadow:
                0 0 10px rgba(0, 212, 255, 0.8),
                0 0 20px rgba(0, 212, 255, 0.4);
        }

        /* Glowy input fields */
        .glow-input {
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(168, 85, 247, 0.3);
            box-shadow:
                0 0 15px rgba(168, 85, 247, 0.1),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .glow-input label {
            display: block;
            font-size: 7px;
            color: #a855f7;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 4px;
            text-shadow: 0 0 6px rgba(168, 85, 247, 0.5);
        }
        .glow-input input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 5px;
            color: #a855f7;
            font-size: 13px;
            font-weight: 600;
            font-family: "Geom", sans-serif;
            outline: none;
            transition: all 0.3s ease;
        }
        .glow-input input[type="number"]:focus {
            border-color: #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
        }

        /* K-way toggle selector */
        .kway-select {
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .kway-select .kway-label {
            display: block;
            font-size: 7px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 6px;
            text-align: center;
        }
        .kway-select .kway-options {
            display: flex;
            gap: 4px;
            justify-content: center;
        }
        .kway-select .kway-option {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px 4px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.25s ease;
            position: relative;
        }
        .kway-select .kway-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }
        .kway-select .kway-option.active {
            background: var(--kway-color, #00d4ff);
            border-color: var(--kway-color, #00d4ff);
            box-shadow: 0 0 12px var(--kway-color, #00d4ff);
        }
        .kway-select .kway-option.active .kway-icon {
            color: #000;
        }
        .kway-select .kway-icon {
            width: 16px;
            height: 16px;
            color: #888;
            transition: all 0.25s ease;
            stroke-width: 2;
        }
        .kway-select .kway-option:hover .kway-icon {
            color: #fff;
        }
        /* Emoji icons in target selector */
        .kway-select .kway-option span.kway-icon {
            font-size: 14px;
            width: auto;
            height: auto;
            filter: grayscale(0.5);
        }
        .kway-select .kway-option:hover span.kway-icon,
        .kway-select .kway-option.active span.kway-icon {
            filter: grayscale(0);
        }

        /* Color variants */
        .kway-select.purple { --kway-color: #a855f7; }
        .kway-select.cyan { --kway-color: #00d4ff; }
        .kway-select.yellow { --kway-color: #fbbf24; }
        .kway-select.red { --kway-color: #ef4444; }
        .kway-select.blue { --kway-color: #3b82f6; }

        /* Party-specific active states */
        .kway-select .kway-option.active.dem {
            background: #3b82f6;
            border-color: #3b82f6;
            box-shadow: 0 0 12px #3b82f6;
        }
        .kway-select .kway-option.active.rep {
            background: #ef4444;
            border-color: #ef4444;
            box-shadow: 0 0 12px #ef4444;
        }
        .kway-select .kway-option.active.tie {
            background: #a855f7;
            border-color: #a855f7;
            box-shadow: 0 0 12px #a855f7;
        }

        /* Glowy buttons - horizontal row */
        .glow-buttons {
            display: flex;
            flex-direction: row;
            gap: 4px;
        }
        .glow-btn {
            flex: 1;
            padding: 10px 0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.25s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .glow-btn .btn-icon {
            width: 16px;
            height: 16px;
            stroke-width: 2.5;
        }
        .glow-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.4s ease;
        }
        .glow-btn:hover::before {
            left: 100%;
        }

        .glow-btn.play {
            background: linear-gradient(135deg, #00d4ff 0%, #0088ff 100%);
            color: #000;
            box-shadow:
                0 0 15px rgba(0, 212, 255, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .glow-btn.play:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow:
                0 0 25px rgba(0, 212, 255, 0.6),
                0 0 50px rgba(0, 212, 255, 0.3);
        }

        .glow-btn.pause {
            background: linear-gradient(135deg, #ff4757 0%, #ff2d3a 100%);
            color: #fff;
            box-shadow:
                0 0 15px rgba(255, 71, 87, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .glow-btn.pause:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow:
                0 0 25px rgba(255, 71, 87, 0.6),
                0 0 50px rgba(255, 71, 87, 0.3);
        }

        .glow-btn.reset {
            background: linear-gradient(135deg, #ffa500 0%, #ff8c00 100%);
            color: #000;
            box-shadow:
                0 0 15px rgba(255, 165, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .glow-btn.reset:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow:
                0 0 25px rgba(255, 165, 0, 0.6),
                0 0 50px rgba(255, 165, 0, 0.3);
        }

        .glow-btn:disabled {
            opacity: 0.25;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        .glow-btn:active:not(:disabled) {
            transform: translateY(0) scale(0.98);
        }

        /* Pulsing animation for running state */
        @keyframes glow-pulse {
            0%, 100% {
                box-shadow:
                    0 0 20px rgba(0, 212, 255, 0.4),
                    0 0 40px rgba(0, 212, 255, 0.2);
            }
            50% {
                box-shadow:
                    0 0 30px rgba(0, 212, 255, 0.6),
                    0 0 60px rgba(0, 212, 255, 0.4);
            }
        }
        .iter-box.running {
            animation: glow-pulse 1.5s ease-in-out infinite;
        }

        /* Carousel component */
        .stat-carousel {
            position: relative;
            overflow: hidden;
            min-width: 70px;
        }
        .stat-carousel .carousel-items {
            position: relative;
            height: 44px;
        }
        .stat-carousel .carousel-item {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.35s ease, transform 0.35s ease;
            pointer-events: none;
        }
        .stat-carousel .carousel-item.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        .stat-carousel .carousel-item.exit {
            opacity: 0;
            transform: translateY(-8px);
        }
        .stat-carousel .carousel-dots {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-top: 6px;
        }
        .stat-carousel .carousel-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .stat-carousel .carousel-dot.active {
            background: var(--carousel-color, #00d4ff);
            box-shadow: 0 0 6px var(--carousel-color, #00d4ff);
        }
        .stat-carousel .carousel-dot:hover {
            background: rgba(255,255,255,0.4);
        }

        #mapCanvas {
            border-radius: 8px;
            background: #ffffff00;
        }
        .loading { text-align: center; padding: 50px; }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Brainrot Dashboard */
        .viz-container { position: relative; width: fit-content; margin: 0 auto; }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
            width: 100%;
        }
        
        .dash-card {
            background: linear-gradient(135deg, #1a1a2e 0%, #252542 100%);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
        }
        .dash-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent, #00d4ff), transparent);
            opacity: 0.5;
        }
        .dash-card.pulse::before {
            animation: pulse-glow 0.5s ease-out;
        }
        @keyframes pulse-glow {
            0% { opacity: 1; height: 4px; }
            100% { opacity: 0.5; height: 2px; }
        }
        
        .dash-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        .dash-value {
            font-size: 38px;
            font-weight: 700;
            color: #fff;
            line-height: 1;
            transition: all 0.3s ease;
        }
        .dash-value.dem, .mini-stat-value.dem { color: #3b82f6; }
        .dash-value.rep, .mini-stat-value.rep { color: #ef4444; }
        .dash-value.neutral { color: #a855f7; }
        
        .dash-subtitle {
            font-size: 11px;
            color: #555;
            margin-top: 2px;
        }
        
        /* Line chart for stats */
        .stat-chart {
            height: 30px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        .stat-chart svg {
            width: 100%;
            height: 100%;
        }
        .stat-line {
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .stat-line.yellow {
            stroke: #fbbf24;
            filter: drop-shadow(0 0 3px #fbbf24) drop-shadow(0 0 6px #fbbf24);
        }
        .stat-line.purple {
            stroke: #a855f7;
            filter: drop-shadow(0 0 3px #a855f7) drop-shadow(0 0 6px #a855f7);
        }
        .stat-area {
            opacity: 0.3;
        }
        .stat-area.yellow { fill: url(#yellowGradient); }
        .stat-area.purple { fill: url(#purpleGradient); }
        
        /* Floating EV Panel (right side) */
        .floating-ev {
            position: absolute;
            top: 0px;
            right: -330px;
            z-index: 100;
            display: flex;
            flex-direction: row;
            gap: 10px;
            font-family: "Geom", sans-serif;
        }

        /* Vertical EV Bar */
        .ev-bar-vertical {
            width: 60px;
            height: 500px;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid rgba(168, 85, 247, 0.3);
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-shadow:
                0 0 20px rgba(168, 85, 247, 0.15),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .ev-bar-track {
            flex: 1;
            background: #222;
            border-radius: 6px;
            overflow: show;
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
        }
        .ev-bar-rep-v {
            background: linear-gradient(180deg, #dc2626 0%, #ef4444 100%);
            width: 100%;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 12px;
            font-weight: 700;
            font-size: 22px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            box-shadow: 0 2px 15px rgba(239,68,68,0.5);
            overflow: visible;
        }
        .ev-bar-rep-swing-v {
            background: linear-gradient(180deg, #f87171 0%, #fca5a5 100%);
            width: 100%;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: #7f1d1d;
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
            overflow: visible;
        }
        .ev-bar-dem-swing-v {
            background: linear-gradient(0deg, #60a5fa 0%, #93c5fd 100%);
            width: 100%;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: #1e3a8a;
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
            overflow: visible;
        }
        .ev-bar-dem-v {
            background: linear-gradient(0deg, #2563eb 0%, #3b82f6 100%);
            width: 100%;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 12px;
            font-weight: 700;
            font-size: 22px;
            color: white;
            text-shadow: 0 -2px 4px rgba(0,0,0,0.5);
            box-shadow: 0 -2px 15px rgba(59,130,246,0.5);
            overflow: visible;
        }
        .ev-270-line {
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 2px;
            background: rgba(255,255,255,0.8);
            transform: translateY(-50%);
            box-shadow: 0 0 8px rgba(255,255,255,0.3);
        }
        .ev-total-label {
            position: absolute;
            left: -45px;
            font-weight: 700;
            font-size: 24px;
            text-shadow: 0 0 10px currentColor;
            transition: all 0.3s ease;
        }
        .ev-total-label.rep {
            top: 8px;
            left: -80px;
            color: #ef4444;
        }
        .ev-total-label.dem {
            bottom: 8px;
            left: -80px;
            color: #3b82f6;
        }
        .ev-total-label.winner {
            font-size: 32px;
            text-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
        }
        .ev-270-label {
            position: absolute;
            right: -28px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            color: #888;
            writing-mode: vertical-rl;
            letter-spacing: 1px;
        }

        /* EV Stats Column */
        .ev-stats-col {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
        }
        .ev-stat-box {
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            min-width: 120px;
        }
        .ev-stat-box .stat-value {
            font-size: 28px;
            font-weight: 700;
            line-height: 1;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        .ev-stat-box .stat-value.dem { color: #3b82f6; text-shadow: 0 0 10px rgba(59,130,246,0.5); }
        .ev-stat-box .stat-value.rep { color: #ef4444; text-shadow: 0 0 10px rgba(239,68,68,0.5); }
        .ev-stat-box .stat-value.purple { color: #a855f7; text-shadow: 0 0 10px rgba(168,85,247,0.5); }
        .ev-stat-box .stat-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-top: 4px;
        }
        .ev-stat-box.stat-carousel .carousel-items {
            height: 48px;
        }
        .ev-stat-box.stat-carousel .carousel-dots {
            margin-top: 6px;
        }
        
        /* Tipping Point Histogram (positioned top-right) */
        .tipping-histogram {
            position: absolute;
            top: -6px;
            right: 6px;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            height: 140px;
            gap: 2px;
        }
        .tipping-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
        }
        .tipping-bar {
            width: 16px;
            border-radius: 2px 2px 0 0;
            min-height: 3px;
            transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s ease;
        }
        .tipping-bar.current {
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
            animation: tipping-glow 1s ease-in-out infinite;
        }
        @keyframes tipping-glow {
            0%, 100% { opacity: 1; box-shadow: 0 0 8px rgba(255,255,255,0.6); }
            50% { opacity: 0.85; box-shadow: 0 0 12px rgba(255,255,255,0.8); }
        }
        .tipping-label {
            font-size: 9px;
            font-weight: 600;
            color: #888;
            text-align: center;
            line-height: 1;
        }
        .tipping-count {
            font-size: 8px;
            color: #666;
            line-height: 1;
        }
        #tippingCard {
            position: relative;
        }
        #tippingCard .dash-value {
            font-size: 26px;
        }
        #tippingCard.pulse .dash-value {
            animation: tipping-flash 0.5s ease-out;
        }
        @keyframes tipping-flash {
            0% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        /* Algorithm Score - invert on sparkline collision */
        #scoreCard {
            position: relative;
        }
        #scoreCard .dash-value {
            mix-blend-mode: normal;
        }

        /* Score line chart */
        .score-chart {
            height: 30px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        .score-chart svg {
            width: 100%;
            height: 100%;
        }
        .score-line {
            fill: none;
            stroke: #00d4ff;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 3px #00d4ff) drop-shadow(0 0 6px #00d4ff);
        }
        .score-area {
            fill: url(#scoreGradient);
            opacity: 0.3;
        }

        /* Histogram */
        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 100%;
            gap: 3px;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 0 10px;
        }
        .hist-bar {
            flex: 1;
            border-radius: 3px 3px 0 0;
            min-height: 2px;
            transition: height 0.3s ease, background 0.3s ease;
        }
        .partisan-card {
            position: relative;
            padding: 0 !important;
            overflow: hidden;
            min-height: 100px;
        }
        .partisan-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 12px;
            z-index: 1;
        }
        .partisan-overlay .dash-label,
        .partisan-overlay .mini-stat-value,
        .partisan-overlay .mini-stat-label {
            mix-blend-mode: difference;
            color: white;
        }
        
        /* Mini stat row */
        .mini-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding-top: 8px;
            padding-left: 10px;
            padding-right: 10px;
            border-top: 1px solid #333;
            overflow: visible;
        }
        .mini-stat {
            text-align: center;
            overflow: visible;
        }
        .mini-stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #00d4ff;
            line-height: 1;
        }
        .mini-stat-label {
            font-size: 9px;
            color: #555;
            text-transform: uppercase;
        }
        .winner-dem { color: #3b82f6 !important; }
        .winner-rep { color: #ef4444 !important; }
        .winner-tie { color: #a855f7 !important; }

        /* State tooltip */
        #stateTooltip {
            position: fixed;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px 14px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-width: 140px;
        }
        #stateTooltip .tooltip-name {
            font-weight: 600;
            font-size: 15px;
            color: #fff;
            margin-bottom: 6px;
        }
        #stateTooltip .tooltip-row {
            font-size: 13px;
            color: #aaa;
            margin: 3px 0;
        }
        #stateTooltip .tooltip-row span {
            color: #fff;
            font-weight: 500;
        }
        #stateTooltip .lean-dem { color: #3b82f6 !important; }
        #stateTooltip .lean-rep { color: #ef4444 !important; }
        #stateTooltip .lean-even { color: #a855f7 !important; }
    </style>
</head>
<body>
    <!-- State tooltip -->
    <div id="stateTooltip">
        <div class="tooltip-name" id="tooltipStateName"></div>
        <div class="tooltip-row">Counties: <span id="tooltipCountyCount"></span></div>
        <div class="tooltip-row">Population: <span id="tooltipPopulation"></span></div>
        <div class="tooltip-row">Electoral Votes: <span id="tooltipEV"></span></div>
        <div class="tooltip-row">Lean: <span id="tooltipLean"></span></div>
    </div>

    <div class="container">
        <div class="viz">
            <div id="loadingState" class="loading">
                <div class="spinner"></div>
                <p>Loading map data...</p>
            </div>
            <div class="viz-container">
                <div class="floating-controls" id="floatingControls" style="display: none;">
                    <div class="iter-box" id="iterBox">
                        <div class="iter-label">Iteration</div>
                        <div class="iter-value" id="iteration">0</div>
                    </div>

                    <div class="glow-input">
                        <label>Terminate After</label>
                        <input type="number" id="iterations" min="100" max="150000" value="5000" step="100">
                    </div>

                    <div class="glow-input">
                        <label>Redraw Period</label>
                        <input type="number" id="renderEvery" min="1" max="500" value="25" step="1">
                    </div>

                    <div class="kway-select purple" id="colorModeKway">
                        <div class="kway-label">Color</div>
                        <div class="kway-options">
                            <div class="kway-option active" data-value="county-partisan" title="County Partisan">
                                <i data-lucide="map-pin" class="kway-icon"></i>
                            </div>
                            <div class="kway-option" data-value="state-partisan" title="State Partisan">
                                <i data-lucide="landmark" class="kway-icon"></i>
                            </div>
                            <div class="kway-option" data-value="state" title="State Colors">
                                <i data-lucide="palette" class="kway-icon"></i>
                            </div>
                        </div>
                    </div>

                    <div class="kway-select" id="targetKway">
                        <div class="kway-label">Target</div>
                        <div class="kway-options">
                            <div class="kway-option active rep" data-value="Republican" title="GOP Victory">
                                <span class="kway-icon">üêò</span>
                            </div>
                            <div class="kway-option dem" data-value="Democratic" title="DEM Victory">
                                <span class="kway-icon">ü´è</span>
                            </div>
                            <div class="kway-option tie" data-value="Tie" title="Electoral Tie">
                                <i data-lucide="scale" class="kway-icon"></i>
                            </div>
                        </div>
                    </div>

                    <div class="kway-select cyan" id="modeKway">
                        <div class="kway-label">Algorithm</div>
                        <div class="kway-options">
                            <div class="kway-option active" data-value="standard" title="Standard">
                                <i data-lucide="shuffle" class="kway-icon"></i>
                            </div>
                            <div class="kway-option" data-value="follow_the_leader" title="Follow Leader">
                                <i data-lucide="crown" class="kway-icon"></i>
                            </div>
                            <div class="kway-option" data-value="bfs" title="BFS">
                                <i data-lucide="waves" class="kway-icon"></i>
                            </div>
                            <div class="kway-option" data-value="dfs" title="DFS">
                                <i data-lucide="git-branch" class="kway-icon"></i>
                            </div>
                        </div>
                    </div>

                    <div class="glow-buttons">
                        <button class="glow-btn play" id="startBtn"><i data-lucide="play" class="btn-icon"></i></button>
                        <button class="glow-btn pause" id="stopBtn" disabled><i data-lucide="pause" class="btn-icon"></i></button>
                        <button class="glow-btn reset" id="resetBtn"><i data-lucide="rotate-ccw" class="btn-icon"></i></button>
                    </div>
                </div>

                <canvas id="mapCanvas" style="display: none;"></canvas>

                <!-- Floating EV Panel (right side) -->
                <div class="floating-ev" id="floatingEV" style="display: none;">
                    <div class="ev-bar-vertical">
                        <div class="ev-bar-track">
                            <div class="ev-bar-rep-v" id="evRepBarV"><span id="evRepV">0</span></div>
                            <div class="ev-bar-rep-swing-v" id="evRepSwingBarV"><span id="evRepSwingV"></span></div>
                            <div class="ev-bar-dem-swing-v" id="evDemSwingBarV"><span id="evDemSwingV"></span></div>
                            <div class="ev-bar-dem-v" id="evDemBarV"><span id="evDemV">0</span></div>
                            <div class="ev-270-line"></div>
                            <span class="ev-total-label rep" id="evTotalRep">0</span>
                            <span class="ev-total-label dem" id="evTotalDem">0</span>
                        </div>
                    </div>
                    <div class="ev-stats-col">
                        <div class="ev-stat-box">
                            <div class="stat-value purple" id="winnerV">-</div>
                            <div class="stat-label">Projected</div>
                        </div>
                        <div class="ev-stat-box">
                            <div class="stat-value" id="evMarginV">0</div>
                            <div class="stat-label">EV Margin</div>
                        </div>
                        <div class="ev-stat-box">
                            <div class="stat-value" id="swingEVs">0</div>
                            <div class="stat-label">Swing EVs</div>
                        </div>
                        <div class="ev-stat-box stat-carousel" id="evCarousel" style="--carousel-color: #a855f7;">
                            <div class="carousel-items">
                                <div class="carousel-item active" data-key="demshare2">
                                    <div class="stat-value dem" id="demShare2">-</div>
                                    <div class="stat-label">Dem Vote</div>
                                </div>
                                <div class="carousel-item" data-key="repshare2">
                                    <div class="stat-value rep" id="repShare2">-</div>
                                    <div class="stat-label">GOP Vote</div>
                                </div>
                                <div class="carousel-item" data-key="year2">
                                    <div class="stat-value purple">2020</div>
                                    <div class="stat-label">Year</div>
                                </div>
                            </div>
                            <div class="carousel-dots"></div>
                        </div>
                    </div>
                </div>
            </div>
                
                <div class="dashboard" id="dashboard" style="display: none;">
                    <!-- Tipping Point State -->
                    <div class="dash-card" id="tippingCard" style="--accent: #a855f7;">
                        <div class="dash-label">Tipping Point</div>
                        <div class="dash-value" id="tippingState" style="color: #a855f7;">-</div>
                        <div class="dash-subtitle" id="tippingSubtitle">decides the election</div>
                        <div class="tipping-histogram" id="tippingHistogram"></div>
                    </div>

                    <!-- Algorithm Score -->
                    <div class="dash-card" id="scoreCard" style="--accent: #00d4ff;">
                        <div class="dash-label">Algorithm Score</div>
                        <div class="dash-value" id="currentScore" style="color: #00d4ff;">0.00</div>
                        <div class="dash-subtitle" id="scoreSubtitle">higher is better</div>
                        <div class="score-chart" id="scoreChart">
                            <svg viewBox="0 0 200 30" preserveAspectRatio="none">
                                <defs>
                                    <linearGradient id="scoreGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#00d4ff;stop-opacity:0.5" />
                                        <stop offset="100%" style="stop-color:#00d4ff;stop-opacity:0" />
                                    </linearGradient>
                                </defs>
                                <path class="score-area" id="scoreArea" d=""></path>
                                <path class="score-line" id="scoreLine" d=""></path>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- Swing States -->
                    <div class="dash-card" id="swingCard" style="--accent: #fbbf24;">
                        <div class="dash-label">Swing States</div>
                        <div class="dash-value" id="swingStates">0</div>
                        <div class="dash-subtitle">within ¬±5% lean</div>
                        <div class="stat-chart">
                            <svg viewBox="0 0 200 30" preserveAspectRatio="none">
                                <defs>
                                    <linearGradient id="yellowGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#fbbf24;stop-opacity:0.5" />
                                        <stop offset="100%" style="stop-color:#fbbf24;stop-opacity:0" />
                                    </linearGradient>
                                </defs>
                                <path class="stat-area yellow" id="swingArea" d=""></path>
                                <path class="stat-line yellow" id="swingLine" d=""></path>
                            </svg>
                        </div>
                    </div>

                    <!-- EV Margin / Electoral Efficiency -->
                    <div class="dash-card" id="fairnessCard" style="--accent: #a855f7;">
                        <div class="dash-label">EV Margin</div>
                        <div class="dash-value" id="evMarginPct" style="color: #a855f7;">0%</div>
                        <div class="dash-subtitle"><span id="fairnessScore">0%</span> efficiency</div>
                        <div class="stat-chart">
                            <svg viewBox="0 0 200 30" preserveAspectRatio="none">
                                <defs>
                                    <linearGradient id="purpleGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#a855f7;stop-opacity:0.5" />
                                        <stop offset="100%" style="stop-color:#a855f7;stop-opacity:0" />
                                    </linearGradient>
                                </defs>
                                <path class="stat-area purple" id="fairnessArea" d=""></path>
                                <path class="stat-line purple" id="fairnessLine" d=""></path>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- Partisan Distribution Histogram -->
                    <div class="dash-card partisan-card" style="--accent: #a855f7; grid-column: span 2;">
                        <div class="histogram" id="partisanHistogram"></div>
                        <div class="partisan-overlay">
                            <div class="dash-label">State Partisan Distribution</div>
                            <div class="mini-stats" style="border: none; padding: 0;">
                                <div class="mini-stat">
                                    <div class="mini-stat-value" id="safeBlue">0</div>
                                    <div class="mini-stat-label">Safe D</div>
                                </div>
                                <div class="mini-stat">
                                    <div class="mini-stat-value" id="leanBlue">0</div>
                                    <div class="mini-stat-label">Likely D</div>
                                </div>
                                <div class="mini-stat">
                                    <div class="mini-stat-value" id="tossup">0</div>
                                    <div class="mini-stat-label">Tossup/Leans</div>
                                </div>
                                <div class="mini-stat">
                                    <div class="mini-stat-value" id="leanRed">0</div>
                                    <div class="mini-stat-label">Likely R</div>
                                </div>
                                <div class="mini-stat">
                                    <div class="mini-stat-value" id="safeRed">0</div>
                                    <div class="mini-stat-label">Safe R</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // Map data
        let geojson = null;
        let palette = [];
        let countyColors = {};
        let countyPaths = {};  // Pre-computed Path2D objects
        let countyEdges = {};  // geoid -> array of edges [{x1,y1,x2,y2}, ...]
        let neighbors = {};    // geoid -> [neighbor geoids]
        let sharedEdges = {};  // "geoid1-geoid2" -> Path2D of shared edge
        let partisanLean = {}; // geoid -> partisan lean value (-1 to 1)
        let population = {};   // geoid -> population
        let stateLeans = {};   // state -> avg partisan lean
        let countyToState = {}; // geoid -> state
        let colorMode = 'county-partisan'; // 'state', 'county-partisan', or 'state-partisan'
        let election = { winner: '-', r_ev: 0, d_ev: 0 };
        let bounds = null;
        let transform = null;

        // Tooltip data (computed once at init, updated on state changes)
        let stateNames = {};        // state abbrev -> full state name
        let stateCountyCounts = {}; // state abbrev -> number of counties
        let stateEVs = {};          // state abbrev -> electoral votes
        let statePopulations = {};  // state abbrev -> total population
        let hoveredState = null;    // Currently hovered state

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loadingState = document.getElementById('loadingState');
        const floatingControls = document.getElementById('floatingControls');
        const floatingEV = document.getElementById('floatingEV');
        const iterBox = document.getElementById('iterBox');
        // Dashboard elements
        const iterationEl = document.getElementById('iteration');
        const dashboard = document.getElementById('dashboard');
        // Vertical EV bar elements
        const evDemBarV = document.getElementById('evDemBarV');
        const evRepBarV = document.getElementById('evRepBarV');
        const evDemSwingBarV = document.getElementById('evDemSwingBarV');
        const evRepSwingBarV = document.getElementById('evRepSwingBarV');
        const evDemVEl = document.getElementById('evDemV');
        const evRepVEl = document.getElementById('evRepV');
        const evDemSwingVEl = document.getElementById('evDemSwingV');
        const evRepSwingVEl = document.getElementById('evRepSwingV');
        const evTotalRepEl = document.getElementById('evTotalRep');
        const evTotalDemEl = document.getElementById('evTotalDem');
        const winnerVEl = document.getElementById('winnerV');
        const evMarginVEl = document.getElementById('evMarginV');
        const swingEVsEl = document.getElementById('swingEVs');
        // Tipping point elements
        const tippingStateEl = document.getElementById('tippingState');
        const tippingSubtitleEl = document.getElementById('tippingSubtitle');
        const tippingHistogram = document.getElementById('tippingHistogram');
        const tippingCard = document.getElementById('tippingCard');
        // Score stat elements
        const currentScoreEl = document.getElementById('currentScore');
        const scoreSubtitleEl = document.getElementById('scoreSubtitle');
        const scoreLine = document.getElementById('scoreLine');
        const scoreArea = document.getElementById('scoreArea');
        // Other dashboard elements
        const swingStatesEl = document.getElementById('swingStates');
        const swingCard = document.getElementById('swingCard');
        const swingLine = document.getElementById('swingLine');
        const swingArea = document.getElementById('swingArea');
        const fairnessScoreEl = document.getElementById('fairnessScore');
        const evMarginPctEl = document.getElementById('evMarginPct');
        const fairnessCard = document.getElementById('fairnessCard');
        const fairnessLine = document.getElementById('fairnessLine');
        const fairnessArea = document.getElementById('fairnessArea');
        const partisanHistogram = document.getElementById('partisanHistogram');
        const safeBlueEl = document.getElementById('safeBlue');
        const leanBlueEl = document.getElementById('leanBlue');
        const tossupEl = document.getElementById('tossup');
        const leanRedEl = document.getElementById('leanRed');
        const safeRedEl = document.getElementById('safeRed');

        // Track historical data for line charts
        let scoreHistory = []; // [{iter, score}, ...]
        let swingHistory = []; // [{iter, value}, ...]
        let fairnessHistory = []; // [{iter, value}, ...]
        let bestScore = -Infinity;
        let bestScoreInt = -Infinity; // Track best integer part for pulse
        let bestEvMarginInt = -1; // Track best EV margin integer for pulse

        // Tipping point tracking
        let tippingPointCounts = {};  // state -> count of times as tipping point
        let currentTippingPoint = null;
        let lastTippingPoint = null;
        let isAlgorithmRunning = false;

        // Carousel elements
        const popVoteMarginEl = document.getElementById('popVoteMargin');
        const totalPopEl = document.getElementById('totalPop');

        /**
         * StatCarousel - Reusable carousel component
         * @param {string} containerId - ID of the carousel container element
         * @param {number} period - Time in ms between rotations (default 5000)
         */
        class StatCarousel {
            constructor(containerId, period = 5000) {
                this.container = document.getElementById(containerId);
                if (!this.container) return;

                this.items = this.container.querySelectorAll('.carousel-item');
                this.dotsContainer = this.container.querySelector('.carousel-dots');
                this.currentIndex = 0;
                this.period = period;
                this.intervalId = null;

                this.init();
            }

            init() {
                if (this.items.length <= 1) return;

                // Create dots
                this.items.forEach((_, i) => {
                    const dot = document.createElement('div');
                    dot.className = 'carousel-dot' + (i === 0 ? ' active' : '');
                    dot.onclick = () => this.goTo(i);
                    this.dotsContainer.appendChild(dot);
                });

                this.dots = this.dotsContainer.querySelectorAll('.carousel-dot');
                this.start();
            }

            start() {
                if (this.intervalId) clearInterval(this.intervalId);
                this.intervalId = setInterval(() => this.next(), this.period);
            }

            stop() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            }

            next() {
                this.goTo((this.currentIndex + 1) % this.items.length);
            }

            goTo(index) {
                if (index === this.currentIndex) return;

                // Exit current
                this.items[this.currentIndex].classList.remove('active');
                this.items[this.currentIndex].classList.add('exit');
                this.dots[this.currentIndex].classList.remove('active');

                // After transition, remove exit class
                setTimeout(() => {
                    this.items[this.currentIndex].classList.remove('exit');
                    this.currentIndex = index;

                    // Enter new
                    this.items[this.currentIndex].classList.add('active');
                    this.dots[this.currentIndex].classList.add('active');
                }, 50);

                // Reset timer on manual navigation
                this.start();
            }

            // Add a new item dynamically
            addItem(key, valueHtml, label) {
                const item = document.createElement('div');
                item.className = 'carousel-item';
                item.dataset.key = key;
                item.innerHTML = `
                    <div class="mini-stat-value" id="${key}Value">${valueHtml}</div>
                    <div class="mini-stat-label">${label}</div>
                `;
                this.container.querySelector('.carousel-items').appendChild(item);

                const dot = document.createElement('div');
                dot.className = 'carousel-dot';
                dot.onclick = () => this.goTo(this.items.length);
                this.dotsContainer.appendChild(dot);

                // Refresh items and dots
                this.items = this.container.querySelectorAll('.carousel-item');
                this.dots = this.dotsContainer.querySelectorAll('.carousel-dot');
            }

            // Update value by key
            updateItem(key, valueHtml, color = null) {
                // Try both mini-stat-value and stat-value classes
                let item = this.container.querySelector(`[data-key="${key}"] .mini-stat-value`);
                if (!item) item = this.container.querySelector(`[data-key="${key}"] .stat-value`);
                if (item) {
                    item.innerHTML = valueHtml;
                    if (color) item.style.color = color;
                }
            }
        }

        // Calculate dashboard metrics
        function calculateDashboardMetrics() {
            const states = Object.keys(stateLeans);
            let swingCount = 0;
            let swingEVs = 0;
            let safeD = 0, leanD = 0, tossup = 0, leanR = 0, safeR = 0;

            for (const state of states) {
                const lean = stateLeans[state] || 0;
                const absLean = Math.abs(lean);
                const ev = stateEVs[state] || 0;

                if (absLean <= 0.05) {
                    swingCount++;
                    swingEVs += ev;
                    tossup++;
                } else if (lean < -0.15) {
                    safeD++;
                } else if (lean < -0.05) {
                    leanD++;
                } else if (lean > 0.15) {
                    safeR++;
                } else if (lean > 0.05) {
                    leanR++;
                }
            }

            // EV Margin: (winner EV %) - (winner popular vote %)
            // Popular vote is fixed based on county partisan lean * population
            let demPopVote = 0, repPopVote = 0;
            for (const [geoid, lean] of Object.entries(partisanLean)) {
                const pop = population[geoid] || 0;
                // lean > 0 means R, lean < 0 means D
                // Approximate: if lean is 0.1, then 55% voted R, 45% voted D
                const rPct = (1 + lean) / 2;
                const dPct = 1 - rPct;
                repPopVote += pop * rPct;
                demPopVote += pop * dPct;
            }
            const totalPopVote = demPopVote + repPopVote;
            const demPopPct = totalPopVote > 0 ? (demPopVote / totalPopVote) * 100 : 50;
            const repPopPct = totalPopVote > 0 ? (repPopVote / totalPopVote) * 100 : 50;

            // EV percentages from election object
            const totalEV = election.d_ev + election.r_ev;
            const demEVPct = totalEV > 0 ? (election.d_ev / totalEV) * 100 : 50;
            const repEVPct = totalEV > 0 ? (election.r_ev / totalEV) * 100 : 50;

            // EV margin = winner's EV% - winner's pop%
            // Positive means EV overperformance, negative means underperformance
            const evWinner = election.d_ev > election.r_ev ? 'dem' : election.r_ev > election.d_ev ? 'rep' : 'tie';
            let evMarginValue = 0;
            if (evWinner === 'dem') {
                evMarginValue = demEVPct - demPopPct;
            } else if (evWinner === 'rep') {
                evMarginValue = repEVPct - repPopPct;
            }

            // Popular vote margin
            const popVoteMargin = Math.abs(demPopPct - repPopPct);
            const popVoteWinner = demPopPct > repPopPct ? 'dem' : repPopPct > demPopPct ? 'rep' : 'tie';

            return {
                swingCount,
                swingEVs,
                evMarginValue,
                evWinner,
                categories: { safeD, leanD, tossup, leanR, safeR },
                stateCount: states.length,
                popVote: {
                    demPct: demPopPct,
                    repPct: repPopPct,
                    margin: popVoteMargin,
                    winner: popVoteWinner,
                    total: totalPopVote
                }
            };
        }

        // Efficient line chart renderer - reuses path strings
        function renderLineChart(lineEl, areaEl, history, width = 200, height = 30, padding = 2) {
            if (!lineEl || !areaEl || history.length < 2) return;

            const values = history.map(d => d.value);
            const minVal = Math.min(...values);
            const maxVal = Math.max(...values);
            const range = maxVal - minVal || 1;
            const maxIter = history[history.length - 1].iter || history.length;

            // Build path string efficiently
            let linePath = '';
            for (let i = 0; i < history.length; i++) {
                const d = history[i];
                const x = (d.iter / maxIter) * width;
                const y = height - padding - ((d.value - minVal) / range) * (height - padding * 2);
                linePath += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1);
            }

            lineEl.setAttribute('d', linePath);

            // Area path
            const lastX = ((history[history.length - 1].iter / maxIter) * width).toFixed(1);
            const firstX = ((history[0].iter / maxIter) * width).toFixed(1);
            areaEl.setAttribute('d', linePath + `L${lastX},${height}L${firstX},${height}Z`);
        }

        // Update partisan histogram with 20 non-uniform bins
        // Bin edges (from center out): 0, 0.5, 1, 2, 4, 6, 10, 15, 22, 30, 100
        // Mirrored for both D and R sides
        function updateHistogram() {
            if (!partisanHistogram) return;

            // Bin edges as percentages (will divide by 100 for lean values)
            const edges = [0, 0.5, 1, 2, 4, 6, 10, 15, 22, 30, 100];
            // 10 bins per side = 20 total
            const bins = new Array(20).fill(0);

            for (const state of Object.keys(stateLeans)) {
                const lean = (stateLeans[state] || 0) * 100; // Convert to percentage

                // Find which bin this lean falls into
                let binIdx;
                if (lean <= 0) {
                    // D side (bins 0-9, where 9 is closest to center)
                    const absLean = Math.abs(lean);
                    for (let i = 0; i < 10; i++) {
                        if (absLean >= edges[10 - i - 1] && absLean < edges[10 - i]) {
                            binIdx = i;
                            break;
                        }
                    }
                    if (binIdx === undefined) binIdx = 0; // Safe D (>30%)
                } else {
                    // R side (bins 10-19, where 10 is closest to center)
                    for (let i = 0; i < 10; i++) {
                        if (lean >= edges[i] && lean < edges[i + 1]) {
                            binIdx = 10 + i;
                            break;
                        }
                    }
                    if (binIdx === undefined) binIdx = 19; // Safe R (>30%)
                }
                bins[binIdx]++;
            }

            const maxBin = Math.max(...bins, 1);

            // Colors: bins 0-1 safe D, 2-3 likely D, 4-7 lean D, 8-11 tossup, 12-15 lean R, 16-17 likely R, 18-19 safe R
            const getColor = (i) => {
                if (i < 2) return '#2563eb';      // Safe D
                if (i < 4) return '#3b82f6';      // Likely D (between safe and lean)
                if (i < 8) return '#60a5fa';      // Lean D
                if (i < 12) return '#a855f7';     // Tossup
                if (i < 16) return '#f87171';     // Lean R
                if (i < 18) return '#ef4444';     // Likely R (between lean and safe)
                return '#dc2626';                  // Safe R
            };

            // Flex widths proportional to bin range size
            // edges diffs: 0.5, 0.5, 1, 2, 2, 4, 5, 7, 8, 70 (but cap the last one)
            const flexWidths = [5, 5, 4, 4, 3, 2, 2, 1, 1, 1, 1,1, 1, 2, 2, 3, 4, 4, 5, 5];

            partisanHistogram.innerHTML = bins.map((count, i) => {
                const height = Math.max(2, (count / maxBin) * 90);
                const color = getColor(i);
                const flex = flexWidths[i];
                return `<div class="hist-bar" style="height: ${height}px; background: ${color}; flex: ${flex};"></div>`;
            }).join('');
        }

        // Update entire dashboard
        function updateDashboard() {
            const metrics = calculateDashboardMetrics();
            const currentIter = scoreHistory.length > 0 ? scoreHistory[scoreHistory.length - 1].iter : swingHistory.length;

            // Update swing states
            if (swingStatesEl) swingStatesEl.textContent = metrics.swingCount;
            swingHistory.push({ iter: currentIter, value: metrics.swingCount });
            renderLineChart(swingLine, swingArea, swingHistory);

            // Pulse effect
            if (swingCard && swingHistory.length > 1 && swingHistory[swingHistory.length - 1].value !== swingHistory[swingHistory.length - 2].value) {
                swingCard.classList.add('pulse');
                setTimeout(() => swingCard.classList.remove('pulse'), 500);
            }

            // Update EV Margin (winner EV% - loser EV%)
            const totalEV = election.d_ev + election.r_ev;
            const demEVPct = totalEV > 0 ? (election.d_ev / totalEV) * 100 : 50;
            const repEVPct = totalEV > 0 ? (election.r_ev / totalEV) * 100 : 50;
            const evMarginPctValue = Math.abs(demEVPct - repEVPct);
            // Signed margin: positive = R winning, negative = D winning
            const evMarginSigned = (repEVPct - demEVPct) / 100;
            if (evMarginPctEl) {
                evMarginPctEl.textContent = evMarginPctValue.toFixed(1) + '%';
                evMarginPctEl.style.color = leanToColor(evMarginSigned * 3);

                // Pulse on new whole percent milestone
                const evMarginInt = Math.floor(evMarginPctValue);
                if (evMarginInt > bestEvMarginInt) {
                    bestEvMarginInt = evMarginInt;
                    const fairnessCard = document.getElementById('fairnessCard');
                    if (fairnessCard) {
                        fairnessCard.classList.add('pulse');
                        setTimeout(() => fairnessCard.classList.remove('pulse'), 500);
                    }
                }
            }

            // Update Electoral Efficiency (EV% - PopVote%)
            // Signed: positive = winner overperforming, need to map to R/D
            const efficiencySigned = metrics.evWinner === 'rep' ? metrics.evMarginValue / 100 :
                                     metrics.evWinner === 'dem' ? -metrics.evMarginValue / 100 : 0;
            if (fairnessScoreEl) {
                const sign = metrics.evMarginValue >= 0 ? '+' : '';
                fairnessScoreEl.textContent = sign + metrics.evMarginValue.toFixed(1) + '%';
                fairnessScoreEl.style.color = leanToColor(efficiencySigned * 3);
            }
            fairnessHistory.push({ iter: currentIter, value: Math.abs(metrics.evMarginValue) });
            renderLineChart(fairnessLine, fairnessArea, fairnessHistory);

            // Update histogram
            updateHistogram();

            // Update category counts
            if (safeBlueEl) safeBlueEl.textContent = metrics.categories.safeD;
            if (leanBlueEl) leanBlueEl.textContent = metrics.categories.leanD;
            if (tossupEl) tossupEl.textContent = metrics.categories.tossup;
            if (leanRedEl) leanRedEl.textContent = metrics.categories.leanR;
            if (safeRedEl) safeRedEl.textContent = metrics.categories.safeR;

            // Update swing EVs
            if (swingEVsEl) swingEVsEl.textContent = metrics.swingEVs;

            // Update tipping point
            updateTippingPoint();

            // Update vertical EV bar
            updateVerticalEVBar();

            // Update EV carousel
            if (evCarousel) {
                const pv = metrics.popVote;
                evCarousel.updateItem('demshare2', pv.demPct.toFixed(1) + '%', '#3b82f6');
                evCarousel.updateItem('repshare2', pv.repPct.toFixed(1) + '%', '#ef4444');
            }

            // Update score display and line chart
            if (currentScoreEl) {
                currentScoreEl.textContent = currentScore.toFixed(2);

                // Pulse on new integer milestone
                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    const scoreInt = Math.floor(currentScore);
                    if (scoreInt > bestScoreInt) {
                        bestScoreInt = scoreInt;
                        const scoreCard = document.getElementById('scoreCard');
                        if (scoreCard) {
                            scoreCard.classList.add('pulse');
                            setTimeout(() => scoreCard.classList.remove('pulse'), 500);
                        }
                    }
                }
            }
            if (scoreSubtitleEl) {
                scoreSubtitleEl.textContent = `best: ${bestScore.toFixed(2)}`;
            }

            // Draw score line chart
            const scoreChartData = scoreHistory.map(d => ({ iter: d.iter, value: d.score }));
            renderLineChart(scoreLine, scoreArea, scoreChartData);
        }

        // Update vertical EV bar
        function updateVerticalEVBar() {
            // Calculate swing EVs for each party
            let demSafeEV = 0, demSwingEV = 0, repSafeEV = 0, repSwingEV = 0;

            for (const [state, lean] of Object.entries(stateLeans)) {
                const ev = stateEVs[state] || 0;
                const isSwing = Math.abs(lean) <= 0.05;

                if (lean < 0) {
                    // Dem-leaning state
                    if (isSwing) {
                        demSwingEV += ev;
                    } else {
                        demSafeEV += ev;
                    }
                } else if (lean > 0) {
                    // Rep-leaning state
                    if (isSwing) {
                        repSwingEV += ev;
                    } else {
                        repSafeEV += ev;
                    }
                } else {
                    // Exactly 0 - split as swing
                    demSwingEV += ev / 2;
                    repSwingEV += ev / 2;
                }
            }

            const totalEV = demSafeEV + demSwingEV + repSafeEV + repSwingEV;
            const demSafePct = totalEV > 0 ? (demSafeEV / totalEV) * 100 : 25;
            const demSwingPct = totalEV > 0 ? (demSwingEV / totalEV) * 100 : 25;
            const repSafePct = totalEV > 0 ? (repSafeEV / totalEV) * 100 : 25;
            const repSwingPct = totalEV > 0 ? (repSwingEV / totalEV) * 100 : 25;

            if (evRepBarV) evRepBarV.style.height = repSafePct + '%';
            if (evRepSwingBarV) evRepSwingBarV.style.height = repSwingPct + '%';
            if (evDemSwingBarV) evDemSwingBarV.style.height = demSwingPct + '%';
            if (evDemBarV) evDemBarV.style.height = demSafePct + '%';

            if (evRepVEl) evRepVEl.textContent = Math.round(repSafeEV);
            if (evRepSwingVEl) evRepSwingVEl.textContent = repSwingEV > 0 ? Math.round(repSwingEV) : '';
            if (evDemSwingVEl) evDemSwingVEl.textContent = demSwingEV > 0 ? Math.round(demSwingEV) : '';
            if (evDemVEl) evDemVEl.textContent = Math.round(demSafeEV);

            // Update winner (based on total EVs)
            const totalDem = demSafeEV + demSwingEV;
            const totalRep = repSafeEV + repSwingEV;
            const winner = totalDem > totalRep ? 'DEM' : totalRep > totalDem ? 'GOP' : 'TIE';

            // Update total labels on the left side
            if (evTotalRepEl) {
                evTotalRepEl.textContent = Math.round(totalRep);
                evTotalRepEl.className = 'ev-total-label rep' + (winner === 'GOP' ? ' winner' : '');
            }
            if (evTotalDemEl) {
                evTotalDemEl.textContent = Math.round(totalDem);
                evTotalDemEl.className = 'ev-total-label dem' + (winner === 'DEM' ? ' winner' : '');
            }

            // Calculate signed margin for coloring: positive = R, negative = D
            const signedMarginPct = (totalRep - totalDem) / 538;

            if (winnerVEl) {
                winnerVEl.textContent = winner;
                winnerVEl.className = 'stat-value';
                winnerVEl.style.color = leanToColor(signedMarginPct * 3);
            }

            // Update EV margin
            const margin = Math.abs(totalDem - totalRep);
            if (evMarginVEl) {
                evMarginVEl.textContent = Math.round(margin);
                evMarginVEl.className = 'stat-value';
                evMarginVEl.style.color = leanToColor(signedMarginPct * 3);
            }
        }

        // Calculate tipping point state
        function calculateTippingPoint() {
            const winner = election.d_ev > election.r_ev ? 'dem' : election.r_ev > election.d_ev ? 'rep' : 'tie';
            if (winner === 'tie') return null;

            const states = Object.keys(stateLeans);

            // Build array of states with their EVs and margin for the winner
            const statesData = states.map(state => {
                const lean = stateLeans[state] || 0;
                const ev = stateEVs[state] || 0;
                // winnerMargin: positive = good for winner, negative = bad for winner
                // If dem wins, negative lean is good (dem-leaning)
                // If rep wins, positive lean is good (rep-leaning)
                const winnerMargin = winner === 'dem' ? -lean : lean;
                return { state, ev, lean, winnerMargin };
            });

            // Sort by winner's margin (safest states first)
            statesData.sort((a, b) => b.winnerMargin - a.winnerMargin);

            // Sum EVs until we hit 270
            let evSum = 0;
            for (const s of statesData) {
                evSum += s.ev;
                if (evSum >= 270) {
                    return { state: s.state, lean: s.lean, margin: s.winnerMargin, ev: s.ev };
                }
            }
            return null;
        }

        // Update tipping point display
        function updateTippingPoint() {
            const tipping = calculateTippingPoint();

            if (!tipping) {
                if (tippingStateEl) tippingStateEl.textContent = '-';
                return;
            }

            currentTippingPoint = tipping.state;

            // Increment count for this state (only when algorithm is running)
            if (isAlgorithmRunning) {
                tippingPointCounts[tipping.state] = (tippingPointCounts[tipping.state] || 0) + 1;
            }

            // Update display with full state name
            if (tippingStateEl) {
                const fullName = stateNames[tipping.state] || tipping.state;
                tippingStateEl.textContent = fullName;
                // Color based on lean
                const lean = tipping.lean;
                if (Math.abs(lean) <= 0.05) {
                    tippingStateEl.style.color = '#a855f7';
                } else if (lean < 0) {
                    tippingStateEl.style.color = '#3b82f6';
                } else {
                    tippingStateEl.style.color = '#ef4444';
                }
            }

            // Update subtitle with margin
            if (tippingSubtitleEl) {
                const marginPct = Math.abs(tipping.margin * 100).toFixed(1);
                const party = tipping.lean < 0 ? 'D' : tipping.lean > 0 ? 'R' : '';
                tippingSubtitleEl.textContent = `${tipping.ev} EVs ‚Ä¢ ${party}+${marginPct}%`;
            }

            // Pulse effect if tipping point changed
            if (lastTippingPoint !== currentTippingPoint && lastTippingPoint !== null) {
                if (tippingCard) {
                    tippingCard.classList.add('pulse');
                    setTimeout(() => tippingCard.classList.remove('pulse'), 500);
                }
            }
            lastTippingPoint = currentTippingPoint;

            // Update histogram
            updateTippingHistogram();
        }

        // Update tipping point histogram (vertical bars)
        function updateTippingHistogram() {
            if (!tippingHistogram) return;

            // Get top 35 states by count
            const sorted = Object.entries(tippingPointCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 35);

            if (sorted.length === 0) {
                tippingHistogram.innerHTML = '';
                return;
            }

            const maxCount = sorted[0][1];

            tippingHistogram.innerHTML = sorted.map(([state, count]) => {
                const height = Math.max(5, (count / maxCount) * 100);
                const lean = stateLeans[state] || 0;
                const color = leanToColor(lean * 25);
                const isCurrent = state === currentTippingPoint;

                return `
                    <div class="tipping-col">
                        <div class="tipping-bar${isCurrent ? ' current' : ''}" style="height: ${height}px; background: ${color};"></div>
                        <span class="tipping-label">${state}</span>
                        <span class="tipping-count">${count}</span>
                    </div>
                `;
            }).join('');
        }

        // Initialize EV carousel
        let evCarousel = null;

        const iterationsInput = document.getElementById('iterations');
        const renderEveryInput = document.getElementById('renderEvery');
        let currentScore = 0;

        // K-way selector state
        let selectedTarget = 'Republican';
        let selectedMode = 'standard';

        // Tooltip elements
        const stateTooltip = document.getElementById('stateTooltip');
        const tooltipStateName = document.getElementById('tooltipStateName');
        const tooltipCountyCount = document.getElementById('tooltipCountyCount');
        const tooltipPopulation = document.getElementById('tooltipPopulation');
        const tooltipEV = document.getElementById('tooltipEV');
        const tooltipLean = document.getElementById('tooltipLean');

        // K-way selector helper
        function setupKwaySelector(containerId, onChange) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const options = container.querySelectorAll('.kway-option');
            options.forEach(opt => {
                opt.addEventListener('click', () => {
                    options.forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');
                    const value = opt.dataset.value;
                    if (onChange) onChange(value);
                });
            });
            // Return getter for current value
            return () => container.querySelector('.kway-option.active')?.dataset.value;
        }

        // Setup k-way selectors
        const getColorMode = setupKwaySelector('colorModeKway', (value) => {
            colorMode = value;
            render();
        });

        const getTarget = setupKwaySelector('targetKway', (value) => {
            selectedTarget = value;
        });

        const getMode = setupKwaySelector('modeKway', (value) => {
            selectedMode = value;
        });

        // Convert partisan lean (-1 to 1) to color (blue to red)
        function leanToColor(lean) {
            // Clamp lean to -1 to 1 range
            lean = Math.max(-1, Math.min(1, lean));

            // Use a more perceptually uniform scale
            // At 0: purple/gray, negative: blue, positive: red
            if (lean < 0) {
                // Democrat (blue) - lean is negative
                // -1 = pure blue, 0 = light purple
                const t = Math.abs(lean); // 0 to 1
                const r = Math.round(200 - t * 180);  // 200 -> 20
                const g = Math.round(200 - t * 120);  // 200 -> 80
                const b = Math.round(210 + t * 35);   // 220 -> 255
                return `rgb(${r},${g},${b})`;
            } else {
                // Republican (red) - lean is positive
                // +1 = pure red, 0 = light purple
                const t = lean; // 0 to 1
                const r = Math.round(210 + t * 35);   // 220 -> 255
                const g = Math.round(200 - t * 180);  // 200 -> 20
                const b = Math.round(200 - t * 180);  // 200 -> 20
                return `rgb(${r},${g},${b})`;
            }
        }

        // Format partisan lean for display
        function formatLean(lean) {
            if (lean === undefined || lean === null) return 'N/A';
            const pct = Math.abs(lean * 100).toFixed(2);
            if (Math.abs(lean) < 0.000005) return 'EVEN';
            return lean > 0 ? 'R+' + pct : 'D+' + pct;
        }

        // Get CSS class for lean
        function getLeanClass(lean) {
            if (lean === undefined || lean === null || Math.abs(lean) < 0.000005) return 'lean-even';
            return lean > 0 ? 'lean-rep' : 'lean-dem';
        }

        // Build state names and county counts from geojson
        function buildStateData() {
            stateNames = {};
            stateCountyCounts = {};

            // Extract from geojson properties
            for (const feature of geojson.features) {
                const props = feature.properties;
                const stateAbbrev = props.STUSPS;
                const stateName = props.STATE_NAME;

                if (stateAbbrev && stateName) {
                    stateNames[stateAbbrev] = stateName;
                }
            }

            // Count counties per state from countyToState
            updateStateCountyCounts();
        }

        // Update county counts and populations when state assignments change
        function updateStateCountyCounts() {
            stateCountyCounts = {};
            statePopulations = {};
            for (const [geoid, state] of Object.entries(countyToState)) {
                stateCountyCounts[state] = (stateCountyCounts[state] || 0) + 1;
                statePopulations[state] = (statePopulations[state] || 0) + (population[geoid] || 0);
            }
            // Recompute EVs based on new populations
            updateStateEVs();
        }

        // Recompute electoral votes based on state populations
        function updateStateEVs() {
            const totalPop = Object.values(statePopulations).reduce((a, b) => a + b, 0);
            if (totalPop === 0) return;
            stateEVs = {};
            for (const [state, pop] of Object.entries(statePopulations)) {
                stateEVs[state] = Math.round(pop * 538 / totalPop);
            }
        }

        // Find which county (and thus state) is under the mouse
        function findStateAtPoint(x, y) {
            for (const [geoid, path] of Object.entries(countyPaths)) {
                if (ctx.isPointInPath(path, x, y)) {
                    return countyToState[geoid];
                }
            }
            return null;
        }

        // Update tooltip content without repositioning (for live updates during animation)
        function updateTooltipContent(state) {
            if (!state) return;

            const stateName = stateNames[state] || state;
            const countyCount = stateCountyCounts[state] || 0;
            const pop = statePopulations[state] || 0;
            const ev = stateEVs[state] || 0;
            const lean = stateLeans[state];

            tooltipStateName.textContent = stateName;
            tooltipCountyCount.textContent = countyCount;
            tooltipPopulation.textContent = pop.toLocaleString();
            tooltipEV.textContent = ev;
            tooltipLean.textContent = formatLean(lean);
            tooltipLean.className = getLeanClass(lean);
        }

        // Show tooltip for a state
        function showTooltip(state, mouseX, mouseY) {
            if (!state) {
                stateTooltip.style.display = 'none';
                return;
            }

            updateTooltipContent(state);

            // Position tooltip near mouse, offset to avoid cursor
            const offsetX = 15;
            const offsetY = 15;
            let left = mouseX + offsetX;
            let top = mouseY + offsetY;

            // Show briefly to measure
            stateTooltip.style.display = 'block';
            const tooltipWidth = stateTooltip.offsetWidth;
            const tooltipHeight = stateTooltip.offsetHeight;

            // Keep tooltip on screen
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (left + tooltipWidth > viewportWidth - 10) {
                left = mouseX - tooltipWidth - offsetX;
            }
            if (top + tooltipHeight > viewportHeight - 10) {
                top = mouseY - tooltipHeight - offsetY;
            }

            stateTooltip.style.left = left + 'px';
            stateTooltip.style.top = top + 'px';
        }

        // Canvas mouse event handlers
        function setupTooltipHandlers() {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const state = findStateAtPoint(x, y);
                hoveredState = state;
                showTooltip(state, e.clientX, e.clientY);
            });

            canvas.addEventListener('mouseleave', () => {
                hoveredState = null;
                stateTooltip.style.display = 'none';
            });
        }

        // Compute bounding box of GeoJSON
        function computeBounds(geojson) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const feature of geojson.features) {
                const coords = feature.geometry.coordinates;
                processCoords(coords, (x, y) => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            }
            return { minX, minY, maxX, maxY };
        }

        function processCoords(coords, fn) {
            if (typeof coords[0] === 'number') {
                fn(coords[0], coords[1]);
            } else {
                for (const c of coords) processCoords(c, fn);
            }
        }

        // Build Path2D for a geometry
        function buildPath(geometry) {
            const path = new Path2D();
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                drawPolygon(path, coords);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    drawPolygon(path, poly);
                }
            }
            return path;
        }

        function drawPolygon(path, rings) {
            for (const ring of rings) {
                let first = true;
                for (const [x, y] of ring) {
                    const [px, py] = project(x, y);
                    if (first) {
                        path.moveTo(px, py);
                        first = false;
                    } else {
                        path.lineTo(px, py);
                    }
                }
                path.closePath();
            }
        }

        function project(lon, lat) {
            const x = (lon - bounds.minX) * transform.scale + transform.offsetX;
            const y = (bounds.maxY - lat) * transform.scale + transform.offsetY;
            return [x, y];
        }

        // Pre-compute all county paths and edges
        function precomputePaths() {
            countyPaths = {};
            countyEdges = {};

            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                countyPaths[geoid] = buildPath(feature.geometry);
                countyEdges[geoid] = extractEdges(feature.geometry);
            }

            // Pre-compute shared edges between neighbors
            precomputeSharedEdges();
        }

        // Extract all edges from a geometry as line segments
        function extractEdges(geometry) {
            const edges = [];
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                extractPolygonEdges(coords, edges);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    extractPolygonEdges(poly, edges);
                }
            }
            return edges;
        }

        function extractPolygonEdges(rings, edges) {
            for (const ring of rings) {
                for (let i = 0; i < ring.length - 1; i++) {
                    const [x1, y1] = project(ring[i][0], ring[i][1]);
                    const [x2, y2] = project(ring[i + 1][0], ring[i + 1][1]);
                    // Store edge with normalized key for comparison
                    edges.push({ x1, y1, x2, y2 });
                }
            }
        }

        // Create a normalized key for an edge (so A->B and B->A match)
        function edgeKey(x1, y1, x2, y2) {
            // Round to avoid floating point issues
            const r = (v) => Math.round(v * 100) / 100;
            const p1 = `${r(x1)},${r(y1)}`;
            const p2 = `${r(x2)},${r(y2)}`;
            return p1 < p2 ? `${p1}-${p2}` : `${p2}-${p1}`;
        }

        // Pre-compute shared edges between neighboring counties
        function precomputeSharedEdges() {
            sharedEdges = {};
            const processed = new Set();

            for (const geoid of Object.keys(countyEdges)) {
                const myNeighbors = neighbors[geoid] || [];
                const myEdgeSet = new Set(countyEdges[geoid].map(e => edgeKey(e.x1, e.y1, e.x2, e.y2)));

                for (const neighborId of myNeighbors) {
                    const pairKey = geoid < neighborId ? `${geoid}-${neighborId}` : `${neighborId}-${geoid}`;
                    if (processed.has(pairKey)) continue;
                    processed.add(pairKey);

                    if (!countyEdges[neighborId]) continue;

                    // Find shared edges
                    const path = new Path2D();
                    let hasShared = false;

                    for (const edge of countyEdges[neighborId]) {
                        const key = edgeKey(edge.x1, edge.y1, edge.x2, edge.y2);
                        if (myEdgeSet.has(key)) {
                            path.moveTo(edge.x1, edge.y1);
                            path.lineTo(edge.x2, edge.y2);
                            hasShared = true;
                        }
                    }

                    if (hasShared) {
                        sharedEdges[pairKey] = path;
                    }
                }
            }
            console.log(`Pre-computed ${Object.keys(sharedEdges).length} shared edges`);
        }

        // Render the map
        function render() {
            const t0 = performance.now();

            ctx.fillStyle = '#252542';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pass 1: Fill all counties
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                const path = countyPaths[geoid];
                let color;

                if (colorMode === 'county-partisan') {
                    // Each county colored by its own partisan lean
                    const lean = partisanLean[geoid];
                    color = lean !== undefined ? leanToColor(lean * 2) : '#cccccc';
                } else if (colorMode === 'state-partisan') {
                    // Each county colored by its state's average partisan lean
                    const state = countyToState[geoid];
                    const lean = state ? stateLeans[state] : undefined;
                    color = lean !== undefined ? leanToColor(lean * 2) : '#cccccc';
                } else {
                    // Unique state colors
                    const colorIdx = countyColors[geoid];
                    color = palette[colorIdx] || '#cccccc';
                }

                ctx.fillStyle = color;
                ctx.fill(path);
            }

            // Pass 2: Draw thin county borders
            ctx.strokeStyle = '#00000022';
            ctx.lineWidth = 0.25;
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                ctx.stroke(countyPaths[geoid]);
            }

            // Pass 3: Draw thick state borders using pre-computed shared edges
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            for (const [pairKey, path] of Object.entries(sharedEdges)) {
                const [geoid1, geoid2] = pairKey.split('-');
                const color1 = countyColors[geoid1];
                const color2 = countyColors[geoid2];

                // Only draw if counties belong to different states
                if (color1 !== color2) {
                    ctx.stroke(path);
                }
            }

        }

        // Initialize
        async function init() {
            try {
                // Load GeoJSON and initial colors in parallel
                const [geoRes, initRes] = await Promise.all([
                    fetch('/api/geojson'),
                    fetch('/api/init')
                ]);

                geojson = await geoRes.json();
                const initData = await initRes.json();
                palette = initData.palette;
                countyColors = initData.colors;
                neighbors = initData.neighbors;
                partisanLean = initData.partisanLean || {};
                population = initData.population || {};
                stateLeans = initData.stateLeans || {};
                countyToState = initData.countyToState || {};
                stateEVs = initData.stateEVs || {};
                statePopulations = initData.statePopulations || {};
                election = initData.election || { winner: '-', r_ev: 0, d_ev: 0 };

                console.log(`Loaded ${geojson.features.length} counties, ${palette.length} colors, ${Object.keys(neighbors).length} neighbor entries, ${Object.keys(partisanLean).length} partisan lean values, ${Object.keys(stateLeans).length} state leans`);

                // Setup canvas
                const width = 1100;
                const height = 500;
                canvas.width = width;
                canvas.height = height;

                // Compute transform
                bounds = computeBounds(geojson);
                const geoWidth = bounds.maxX - bounds.minX;
                const geoHeight = bounds.maxY - bounds.minY;
                const scaleX = (width - 40) / geoWidth;
                const scaleY = (height - 40) / geoHeight;
                transform = {
                    scale: Math.min(scaleX, scaleY),
                    offsetX: 20,
                    offsetY: 20
                };

                // Pre-compute paths
                precomputePaths();

                // Build state data for tooltips
                buildStateData();

                // Setup tooltip event handlers
                setupTooltipHandlers();

                // Initial render
                render();

                // Show canvas and controls
                loadingState.style.display = 'none';
                canvas.style.display = 'block';
                if (floatingControls) floatingControls.style.display = 'flex';
                if (floatingEV) floatingEV.style.display = 'flex';
                if (dashboard) dashboard.style.display = 'grid';

                // Initialize carousels
                evCarousel = new StatCarousel('evCarousel', 4000);

                updateVerticalEVBar();
                updateDashboard();

            } catch (err) {
                console.error('Init error:', err);
                loadingState.innerHTML = '<p>Error loading map: ' + err.message + '</p>';
            }
        }

        // Socket handlers
        socket.on('color_update', (data) => {
            countyColors = data.colors;
            if (data.stateLeans) stateLeans = data.stateLeans;
            if (data.countyToState) {
                countyToState = data.countyToState;
                updateStateCountyCounts();
            }
            if (data.election) {
                election = data.election;
            }
            if (data.score !== undefined) {
                currentScore = data.score;
                // Track score with iteration for chart
                if (data.generation !== undefined) {
                    scoreHistory.push({ iter: data.generation, score: currentScore });
                }
            }

            render();

            // Update brainrot dashboard
            updateDashboard();

            // Refresh tooltip if currently hovering over a state
            if (hoveredState && stateTooltip.style.display !== 'none') {
                updateTooltipContent(hoveredState);
            }

            if (iterationEl) iterationEl.textContent = data.generation.toLocaleString();
        });

        socket.on('algorithm_started', (data) => {
            isAlgorithmRunning = true;
        });

        socket.on('algorithm_complete', () => {
            startBtn.disabled = false;
            stopBtn.disabled = true;
            if (iterBox) iterBox.classList.remove('running');
            isAlgorithmRunning = false;
        });

        socket.on('error', (data) => {
            console.error('Error:', data.message);
            startBtn.disabled = false;
            stopBtn.disabled = true;
            if (iterBox) iterBox.classList.remove('running');
            isAlgorithmRunning = false;
        });

        // Button handlers
        startBtn.onclick = () => {
            socket.emit('start_algorithm', {
                generations: parseInt(iterationsInput.value),
                render_every: parseInt(renderEveryInput.value),
                target: getTarget() || selectedTarget,
                mode: getMode() || selectedMode
            });
            startBtn.disabled = true;
            stopBtn.disabled = false;
            if (iterBox) iterBox.classList.add('running');
            isAlgorithmRunning = true;
        };

        stopBtn.onclick = () => {
            socket.emit('stop_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            if (iterBox) iterBox.classList.remove('running');
            isAlgorithmRunning = false;
        };

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.onclick = () => {
            socket.emit('reset_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            if (iterBox) iterBox.classList.remove('running');
        };

        socket.on('reset_complete', (data) => {
            countyColors = data.colors;
            if (data.countyToState) {
                countyToState = data.countyToState;
                updateStateCountyCounts();
            }
            if (data.stateLeans) stateLeans = data.stateLeans;
            if (data.election) election = data.election;

            // Reset all chart histories
            currentScore = 0;
            bestScore = -Infinity;
            bestScoreInt = -Infinity;
            bestEvMarginInt = -1;
            scoreHistory = [];
            swingHistory = [];
            fairnessHistory = [];
            if (currentScoreEl) currentScoreEl.textContent = '0.00';
            if (scoreSubtitleEl) scoreSubtitleEl.textContent = 'higher is better';
            if (scoreLine) scoreLine.setAttribute('d', '');
            if (scoreArea) scoreArea.setAttribute('d', '');
            if (swingLine) swingLine.setAttribute('d', '');
            if (swingArea) swingArea.setAttribute('d', '');
            if (fairnessLine) fairnessLine.setAttribute('d', '');
            if (fairnessArea) fairnessArea.setAttribute('d', '');

            // Reset tipping point tracking
            tippingPointCounts = {};
            currentTippingPoint = null;
            lastTippingPoint = null;
            isAlgorithmRunning = false;
            if (tippingHistogram) tippingHistogram.innerHTML = '';

            render();
            iterationEl.textContent = '0';
            updateVerticalEVBar();
            updateDashboard();
        });

        // Initialize Lucide icons
        lucide.createIcons();

        // Start
        init();
    </script>
</body>
</html>
