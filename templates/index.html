<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>US Border Redistricting Simulation</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        .header { text-align: center; padding: 20px; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; color: #fff; }
        .header p { font-size: 1.1em; color: #aaa; }
        .main { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        .controls {
            background: #252542;
            padding: 25px;
            border-radius: 10px;
            height: fit-content;
        }
        .control-group { margin-bottom: 25px; }
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #fff;
        }
        .control-group input[type="range"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 5px;
            color: #fff;
        }
        .range-value { text-align: right; color: #aaa; font-size: 14px; margin-top: 5px; }
        .buttons { display: flex; gap: 10px; margin-bottom: 20px; }
        button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        #startBtn { background: #00d4ff; color: #000; }
        #startBtn:hover:not(:disabled) { background: #00bfea; transform: translateY(-2px); }
        #stopBtn { background: #ff4757; color: #fff; }
        #stopBtn:hover:not(:disabled) { background: #ee2e3f; transform: translateY(-2px); }
        #resetBtn { background: #ffa500; color: #000; }
        #resetBtn:hover:not(:disabled) { background: #e69500; transform: translateY(-2px); }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        .status-box {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .status-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        .status-value { font-size: 16px; color: #fff; }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #1a1a2e;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #0088ff);
            width: 0%;
            transition: width 0.1s;
        }
        .viz {
            background: #252542;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #mapCanvas {
            border-radius: 8px;
            background: #ffffff00;
        }
        .loading { text-align: center; padding: 50px; }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
        }
        .stat {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 5px;
            text-align: center;
        }
        .stat-label { font-size: 11px; color: #aaa; text-transform: uppercase; margin-bottom: 3px; }
        .stat-value { font-size: 22px; font-weight: 700; color: #00d4ff; }
        .info {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #00d4ff;
            margin-bottom: 20px;
        }
        .info p { margin: 5px 0; color: #aaa; font-size: 14px; line-height: 1.6; }
        .election-results {
            width: 100%;
            margin-top: 15px;
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
        }
        .ev-bar {
            display: flex;
            height: 30px;
            border-radius: 5px;
            overflow: hidden;
            background: #333;
        }
        .ev-dem {
            background: linear-gradient(90deg, #2563eb, #3b82f6);
            height: 100%;
            transition: width 0.3s ease;
        }
        .ev-rep {
            background: linear-gradient(90deg, #dc2626, #ef4444);
            height: 100%;
            transition: width 0.3s ease;
        }
        .ev-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        .ev-dem-label { color: #3b82f6; }
        .ev-rep-label { color: #ef4444; }
        .winner-dem { color: #3b82f6 !important; }
        .winner-rep { color: #ef4444 !important; }
        .winner-tie { color: #a855f7 !important; }
    </style>
</head>
<body>
    <div class="container">

        <div class="main">
            <div class="controls">

                <div class="control-group">
                    <label>Iterations</label>
                    <input type="number" id="iterations" min="100" max="150000" value="5000" step="100" style="width: 100%; padding: 10px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #fff; font-size: 14px;">
                </div>

                <div class="control-group">
                    <label>Update Every N Iterations</label>
                    <input type="number" id="renderEvery" min="1" max="500" value="25" step="1" style="width: 100%; padding: 10px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #fff; font-size: 14px;">
                </div>

                <div class="control-group">
                    <label>Color Mode</label>
                    <select id="colorModeSelect" style="width: 100%; padding: 10px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #fff; font-size: 14px;">
                        <option value="county-partisan">County Partisan Lean</option>
                        <option value="state-partisan">State Avg Partisan Lean</option>
                        <option value="state">Unique State Colors</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Optimization Target</label>
                    <select id="targetSelect" style="width: 100%; padding: 10px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #fff; font-size: 14px;">
                        <option value="Republican">Republican Win</option>
                        <option value="Democratic">Democratic Win</option>
                        <option value="Tie">Tie</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Algorithm Mode</label>
                    <select id="modeSelect" style="width: 100%; padding: 10px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #fff; font-size: 14px;">
                        <option value="standard">Standard (Random)</option>
                        <option value="follow_the_leader">Follow the Leader</option>
                        <option value="bfs">BFS</option>
                        <option value="dfs">DFS</option>
                    </select>
                </div>

                <div class="buttons">
                    <button id="startBtn">Play</button>
                    <button id="stopBtn" disabled>Stop</button>
                    <button id="resetBtn">Reset</button>
                </div>

                <div class="status-box">
                    <div class="status-label">Status</div>
                    <div class="status-value" id="statusText">Loading...</div>
                </div>

                <div class="status-box">
                    <div class="status-label">Progress</div>
                    <div class="status-value" id="progressText">0 / 0</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                </div>
            </div>

            <div class="viz">
                <div id="loadingState" class="loading">
                    <div class="spinner"></div>
                    <p>Loading map data...</p>
                </div>
                <canvas id="mapCanvas" style="display: none;"></canvas>
                <div class="stats" id="stats" style="display: none;">
                    <div class="stat">
                        <div class="stat-label">Iteration</div>
                        <div class="stat-value" id="iteration">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Winner</div>
                        <div class="stat-value" id="winner">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="score">0</div>
                    </div>
                </div>
                <div class="election-results" id="electionResults" style="display: none;">
                    <div class="ev-bar">
                        <div class="ev-dem" id="evDemBar"></div>
                        <div class="ev-rep" id="evRepBar"></div>
                    </div>
                    <div class="ev-labels">
                        <span class="ev-dem-label"><span id="evDem">0</span> Dem</span>
                        <span class="ev-rep-label"><span id="evRep">0</span> Rep</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // Map data
        let geojson = null;
        let palette = [];
        let countyColors = {};
        let countyPaths = {};  // Pre-computed Path2D objects
        let countyEdges = {};  // geoid -> array of edges [{x1,y1,x2,y2}, ...]
        let neighbors = {};    // geoid -> [neighbor geoids]
        let sharedEdges = {};  // "geoid1-geoid2" -> Path2D of shared edge
        let partisanLean = {}; // geoid -> partisan lean value (-1 to 1)
        let population = {};   // geoid -> population
        let stateLeans = {};   // state -> avg partisan lean
        let countyToState = {}; // geoid -> state
        let colorMode = 'county-partisan'; // 'state', 'county-partisan', or 'state-partisan'
        let election = { winner: '-', r_ev: 0, d_ev: 0 };
        let bounds = null;
        let transform = null;

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loadingState = document.getElementById('loadingState');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const stats = document.getElementById('stats');
        const iterationEl = document.getElementById('iteration');
        const winnerEl = document.getElementById('winner');
        const scoreEl = document.getElementById('score');
        const electionResults = document.getElementById('electionResults');
        const evDemBar = document.getElementById('evDemBar');
        const evRepBar = document.getElementById('evRepBar');
        const evDemEl = document.getElementById('evDem');
        const evRepEl = document.getElementById('evRep');
        const iterationsInput = document.getElementById('iterations');
        const renderEveryInput = document.getElementById('renderEvery');
        const targetSelect = document.getElementById('targetSelect');
        const modeSelect = document.getElementById('modeSelect');
        let currentScore = 0;

        iterationsInput.oninput = () => {
            document.getElementById('iterationsValue').textContent = iterationsInput.value;
        };
        renderEveryInput.oninput = () => {
            document.getElementById('renderEveryValue').textContent = renderEveryInput.value;
        };

        // Color mode select
        const colorModeSelect = document.getElementById('colorModeSelect');
        colorModeSelect.onchange = () => {
            colorMode = colorModeSelect.value;
            render();
        };

        // Update election display
        function updateElectionDisplay() {
            const totalEV = election.r_ev + election.d_ev;
            const demPct = totalEV > 0 ? (election.d_ev / totalEV) * 100 : 50;
            const repPct = totalEV > 0 ? (election.r_ev / totalEV) * 100 : 50;

            evDemBar.style.width = demPct + '%';
            evRepBar.style.width = repPct + '%';
            evDemEl.textContent = election.d_ev;
            evRepEl.textContent = election.r_ev;

            // Update winner display
            winnerEl.textContent = election.winner;
            winnerEl.className = 'stat-value';
            if (election.winner === 'Democratic') {
                winnerEl.classList.add('winner-dem');
            } else if (election.winner === 'Republican') {
                winnerEl.classList.add('winner-rep');
            } else {
                winnerEl.classList.add('winner-tie');
            }
        }

        // Convert partisan lean (-1 to 1) to color (blue to red)
        function leanToColor(lean) {
            // Clamp lean to -1 to 1 range
            lean = Math.max(-1, Math.min(1, lean));

            // Use a more perceptually uniform scale
            // At 0: purple/gray, negative: blue, positive: red
            if (lean < 0) {
                // Democrat (blue) - lean is negative
                // -1 = pure blue, 0 = light purple
                const t = Math.abs(lean); // 0 to 1
                const r = Math.round(200 - t * 180);  // 200 -> 20
                const g = Math.round(200 - t * 180);  // 200 -> 20
                const b = Math.round(220 + t * 35);   // 220 -> 255
                return `rgb(${r},${g},${b})`;
            } else {
                // Republican (red) - lean is positive
                // +1 = pure red, 0 = light purple
                const t = lean; // 0 to 1
                const r = Math.round(220 + t * 35);   // 220 -> 255
                const g = Math.round(200 - t * 180);  // 200 -> 20
                const b = Math.round(200 - t * 180);  // 200 -> 20
                return `rgb(${r},${g},${b})`;
            }
        }

        // Compute bounding box of GeoJSON
        function computeBounds(geojson) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const feature of geojson.features) {
                const coords = feature.geometry.coordinates;
                processCoords(coords, (x, y) => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            }
            return { minX, minY, maxX, maxY };
        }

        function processCoords(coords, fn) {
            if (typeof coords[0] === 'number') {
                fn(coords[0], coords[1]);
            } else {
                for (const c of coords) processCoords(c, fn);
            }
        }

        // Build Path2D for a geometry
        function buildPath(geometry) {
            const path = new Path2D();
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                drawPolygon(path, coords);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    drawPolygon(path, poly);
                }
            }
            return path;
        }

        function drawPolygon(path, rings) {
            for (const ring of rings) {
                let first = true;
                for (const [x, y] of ring) {
                    const [px, py] = project(x, y);
                    if (first) {
                        path.moveTo(px, py);
                        first = false;
                    } else {
                        path.lineTo(px, py);
                    }
                }
                path.closePath();
            }
        }

        function project(lon, lat) {
            const x = (lon - bounds.minX) * transform.scale + transform.offsetX;
            const y = (bounds.maxY - lat) * transform.scale + transform.offsetY;
            return [x, y];
        }

        // Pre-compute all county paths and edges
        function precomputePaths() {
            countyPaths = {};
            countyEdges = {};

            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                countyPaths[geoid] = buildPath(feature.geometry);
                countyEdges[geoid] = extractEdges(feature.geometry);
            }

            // Pre-compute shared edges between neighbors
            precomputeSharedEdges();
        }

        // Extract all edges from a geometry as line segments
        function extractEdges(geometry) {
            const edges = [];
            const type = geometry.type;
            const coords = geometry.coordinates;

            if (type === 'Polygon') {
                extractPolygonEdges(coords, edges);
            } else if (type === 'MultiPolygon') {
                for (const poly of coords) {
                    extractPolygonEdges(poly, edges);
                }
            }
            return edges;
        }

        function extractPolygonEdges(rings, edges) {
            for (const ring of rings) {
                for (let i = 0; i < ring.length - 1; i++) {
                    const [x1, y1] = project(ring[i][0], ring[i][1]);
                    const [x2, y2] = project(ring[i + 1][0], ring[i + 1][1]);
                    // Store edge with normalized key for comparison
                    edges.push({ x1, y1, x2, y2 });
                }
            }
        }

        // Create a normalized key for an edge (so A->B and B->A match)
        function edgeKey(x1, y1, x2, y2) {
            // Round to avoid floating point issues
            const r = (v) => Math.round(v * 100) / 100;
            const p1 = `${r(x1)},${r(y1)}`;
            const p2 = `${r(x2)},${r(y2)}`;
            return p1 < p2 ? `${p1}-${p2}` : `${p2}-${p1}`;
        }

        // Pre-compute shared edges between neighboring counties
        function precomputeSharedEdges() {
            sharedEdges = {};
            const processed = new Set();

            for (const geoid of Object.keys(countyEdges)) {
                const myNeighbors = neighbors[geoid] || [];
                const myEdgeSet = new Set(countyEdges[geoid].map(e => edgeKey(e.x1, e.y1, e.x2, e.y2)));

                for (const neighborId of myNeighbors) {
                    const pairKey = geoid < neighborId ? `${geoid}-${neighborId}` : `${neighborId}-${geoid}`;
                    if (processed.has(pairKey)) continue;
                    processed.add(pairKey);

                    if (!countyEdges[neighborId]) continue;

                    // Find shared edges
                    const path = new Path2D();
                    let hasShared = false;

                    for (const edge of countyEdges[neighborId]) {
                        const key = edgeKey(edge.x1, edge.y1, edge.x2, edge.y2);
                        if (myEdgeSet.has(key)) {
                            path.moveTo(edge.x1, edge.y1);
                            path.lineTo(edge.x2, edge.y2);
                            hasShared = true;
                        }
                    }

                    if (hasShared) {
                        sharedEdges[pairKey] = path;
                    }
                }
            }
            console.log(`Pre-computed ${Object.keys(sharedEdges).length} shared edges`);
        }

        // Render the map
        function render() {
            const t0 = performance.now();

            ctx.fillStyle = '#252542';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pass 1: Fill all counties
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                const path = countyPaths[geoid];
                let color;

                if (colorMode === 'county-partisan') {
                    // Each county colored by its own partisan lean
                    const lean = partisanLean[geoid];
                    color = lean !== undefined ? leanToColor(lean) : '#cccccc';
                } else if (colorMode === 'state-partisan') {
                    // Each county colored by its state's average partisan lean
                    const state = countyToState[geoid];
                    const lean = state ? stateLeans[state] : undefined;
                    color = lean !== undefined ? leanToColor(lean) : '#cccccc';
                } else {
                    // Unique state colors
                    const colorIdx = countyColors[geoid];
                    color = palette[colorIdx] || '#cccccc';
                }

                ctx.fillStyle = color;
                ctx.fill(path);
            }

            // Pass 2: Draw thin county borders
            ctx.strokeStyle = '#00000022';
            ctx.lineWidth = 0.25;
            for (const feature of geojson.features) {
                const geoid = feature.properties.GEOID;
                ctx.stroke(countyPaths[geoid]);
            }

            // Pass 3: Draw thick state borders using pre-computed shared edges
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            for (const [pairKey, path] of Object.entries(sharedEdges)) {
                const [geoid1, geoid2] = pairKey.split('-');
                const color1 = countyColors[geoid1];
                const color2 = countyColors[geoid2];

                // Only draw if counties belong to different states
                if (color1 !== color2) {
                    ctx.stroke(path);
                }
            }

        }

        // Initialize
        async function init() {
            try {
                // Load GeoJSON and initial colors in parallel
                const [geoRes, initRes] = await Promise.all([
                    fetch('/api/geojson'),
                    fetch('/api/init')
                ]);

                geojson = await geoRes.json();
                const initData = await initRes.json();
                palette = initData.palette;
                countyColors = initData.colors;
                neighbors = initData.neighbors;
                partisanLean = initData.partisanLean || {};
                population = initData.population || {};
                stateLeans = initData.stateLeans || {};
                countyToState = initData.countyToState || {};
                election = initData.election || { winner: '-', r_ev: 0, d_ev: 0 };

                console.log(`Loaded ${geojson.features.length} counties, ${palette.length} colors, ${Object.keys(neighbors).length} neighbor entries, ${Object.keys(partisanLean).length} partisan lean values, ${Object.keys(stateLeans).length} state leans`);

                // Setup canvas
                const width = 1100;
                const height = 500;
                canvas.width = width;
                canvas.height = height;

                // Compute transform
                bounds = computeBounds(geojson);
                const geoWidth = bounds.maxX - bounds.minX;
                const geoHeight = bounds.maxY - bounds.minY;
                const scaleX = (width - 40) / geoWidth;
                const scaleY = (height - 40) / geoHeight;
                transform = {
                    scale: Math.min(scaleX, scaleY),
                    offsetX: 20,
                    offsetY: 20
                };

                // Pre-compute paths
                precomputePaths();

                // Initial render
                render();

                // Show canvas
                loadingState.style.display = 'none';
                canvas.style.display = 'block';
                stats.style.display = 'grid';
                electionResults.style.display = 'block';
                updateElectionDisplay();
                statusText.textContent = 'Ready';

            } catch (err) {
                console.error('Init error:', err);
                loadingState.innerHTML = '<p>Error loading map: ' + err.message + '</p>';
            }
        }

        // Socket handlers
        socket.on('color_update', (data) => {
            countyColors = data.colors;
            if (data.stateLeans) stateLeans = data.stateLeans;
            if (data.countyToState) countyToState = data.countyToState;
            if (data.election) {
                election = data.election;
                updateElectionDisplay();
            }
            if (data.score !== undefined) {
                currentScore = data.score;
                scoreEl.textContent = currentScore.toFixed(2);
            }
            render();

            const prog = (data.generation / data.total) * 100;
            progressBar.style.width = prog + '%';
            progressText.textContent = `${data.generation} / ${data.total}`;
            iterationEl.textContent = data.generation;
        });

        socket.on('algorithm_started', (data) => {
            progressText.textContent = `0 / ${data.iterations}`;
        });

        socket.on('algorithm_complete', () => {
            statusText.textContent = 'Complete';
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        socket.on('error', (data) => {
            statusText.textContent = 'Error: ' + data.message;
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        // Button handlers
        startBtn.onclick = () => {
            socket.emit('start_algorithm', {
                generations: parseInt(iterationsInput.value),
                render_every: parseInt(renderEveryInput.value),
                target: targetSelect.value,
                mode: modeSelect.value
            });
            startBtn.disabled = true;
            stopBtn.disabled = false;
            const modeLabel = modeSelect.value === 'follow_the_leader' ? 'FTL' : 'Std';
            statusText.textContent = 'Running (' + targetSelect.value + ', ' + modeLabel + ')';
            stats.style.display = 'grid';
        };

        stopBtn.onclick = () => {
            socket.emit('stop_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusText.textContent = 'Stopped';
        };

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.onclick = () => {
            socket.emit('reset_algorithm');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusText.textContent = 'Resetting...';
        };

        socket.on('reset_complete', (data) => {
            countyColors = data.colors;
            render();
            progressBar.style.width = '0%';
            progressText.textContent = '0 / 0';
            iterationEl.textContent = '0';
            percentEl.textContent = '0%';
            statusText.textContent = 'Ready';
        });

        // Start
        init();
    </script>
</body>
</html>
